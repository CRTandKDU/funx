<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-02-13 sam. 20:12 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>A Functional Perspective on the NXP Architecture</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="jmc" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">A Functional Perspective on the NXP Architecture
<br />
<span class="subtitle">Version 1.0</span>
</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org1520ea4">1. Introduction</a>
<ul>
<li><a href="#orge0adb7d">1.1. A Dominant View, Symbolic Artificial Intelligence</a></li>
<li><a href="#org5c1472b">1.2. Production Systems and Rule-based Systems</a>
<ul>
<li><a href="#org24b1eca">1.2.1. Neo-classical Rule System Architecture</a></li>
<li><a href="#org4069604">1.2.2. Rules are put to many uses in inference</a></li>
<li><a href="#orgb7fbf1e">1.2.3. Rules with and without symbols</a></li>
</ul>
</li>
<li><a href="#orgc595062">1.3. Clinical Consultation as a Task Environment</a>
<ul>
<li><a href="#org4198827">1.3.1. Old and Long History of Medical Applications of AI</a></li>
<li><a href="#orgc0f05e0">1.3.2. There Were Many, Many Inspiring Accomplishments in AIM</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org08d0657">2. How we got here</a>
<ul>
<li><a href="#org70f0bae">2.1. NXP Archeology and vestigial software artifacts</a></li>
<li><a href="#org78f0fa5">2.2. Meanwhile functionalism thrives in the philosophy of mind</a></li>
<li><a href="#org38cbee7">2.3. And functional programming languages in computer science</a>
<ul>
<li><a href="#orgc281939">2.3.1. Evaluation, Compilation and Abstract Machines</a></li>
<li><a href="#org96fde80">2.3.2. Strict v. Lazy Evaluation</a></li>
<li><a href="#orgcfaf55c">2.3.3. I/O and GUI</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org271f9cf">3. A simplistic functional language, funx</a>
<ul>
<li><a href="#org0e6d5a8">3.1. FUNX a functional language, pure and simplistic</a></li>
<li><a href="#orgf3f55ca">3.2. FUNX SECD Abstract Machine</a>
<ul>
<li><a href="#orge021ee4">3.2.1. Operational semantics</a></li>
<li><a href="#org72e7fc8">3.2.2. Running the funx SECD Abstract Machine</a></li>
<li><a href="#org259e100">3.2.3. A funx strict compiler</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge12a3fb">4. Extending for NXP-style inferencing, funxp</a>
<ul>
<li><a href="#org7770835">4.1. Promises are delayed evaluations</a>
<ul>
<li><a href="#org1a5cb7b">4.1.1. lazy-group</a></li>
<li><a href="#org881464e">4.1.2. Lazy evaluation</a></li>
</ul>
</li>
<li><a href="#org363d395">4.2. Rules and Knowledge Bases</a>
<ul>
<li><a href="#org89274ab">4.2.1. Interactive user interfaces</a></li>
<li><a href="#org6da13b9">4.2.2. Goal-driven evaluation</a></li>
<li><a href="#org91fc27d">4.2.3. Event-driven evaluation</a></li>
<li><a href="#org9cd7a5e">4.2.4. Heuristics design space</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org91edd7e">5. Compiling funxp</a>
<ul>
<li><a href="#org35410b7">5.1. Mapping NXP to SECD</a></li>
<li><a href="#orgd58d4ed">5.2. I/O extensions</a></li>
<li><a href="#org313ffd8">5.3. Backward Chaining</a></li>
<li><a href="#orge852ddd">5.4. Forward Chaining</a></li>
<li><a href="#orgd1384c2">5.5. Evocation</a></li>
<li><a href="#org86dbdf2">5.6. Compiling it all together</a></li>
</ul>
</li>
<li><a href="#org3c2e12c">6. An Emacs-based client</a>
<ul>
<li><a href="#orge50aee3">6.1. Session. Interactivity. Trace and protocol.</a></li>
<li><a href="#org5df8cdf">6.2. Encyclopedia and tree representation. Commands.</a></li>
</ul>
</li>
<li><a href="#orgf18ee68">7. Bibliography</a></li>
<li><a href="#org865591a">8. Index</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1520ea4" class="outline-2">
<h2 id="org1520ea4"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Most of the ideas expressed in the historical series of computer programs, termed <i>NXP Architecture</i> in this paper, were originally designed at the apex of one of the recurring return in the 30-year cycle in the Artificial Intelligence (AI) debate,  
</p>
</div>

<div id="outline-container-orge0adb7d" class="outline-3">
<h3 id="orge0adb7d"><span class="section-number-3">1.1</span> A Dominant View, Symbolic Artificial Intelligence</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Progressively in the late 70s and early 80s, the symbolic thread triumphed as the dominant paradigm of AI research. In 1984 for instance, at the climax of this cycle, early efforts to transfer research work to industrial applications were so introduced:
</p>

<blockquote>
<p>
Artificial Intelligence is the subfield of computer science concerned with symbolic reasoning and problem-solving. [&#x2026;] Knowledge Engineering is the process of incorporating symbolic knowledge into computer systems to solve problems normally requiring human attention and intelligence.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>
</blockquote>

<p>
These computer systems incorporating symbolic knowledge became known as <i>Expert Systems</i> and were all the rage, as industrial applications of AI, from the early eighties to the mid-nineties.
</p>

<p>
This somewhat restricted, to contemporary eyes, view of AI as a &ldquo;subfield of computer science&rdquo; geared towards augmenting traditional programs with symbolic knowledge was, however, perfectly in line with the precepts of the symbolic thread of AI research, established at the <i>Dartmouth Summer Research Project on Artificial Intelligence</i> in 1956. Out of the variety of research theses on &ldquo;thinking machines&rdquo; in the 1950s, diversely known as <i>cybernetics</i>, <i>automata theory</i> or <i>complex information processing</i>, stemmed out the original characteristics of the symbolic approach to AI: the importance of (mathematical) logic in high-level cognitive processes, and the prevalence of symbols in all aspects of cognition.
</p>

<p>
The defining assumption, <i>the physical symbol system hypothesis</i>, was the philosophical perspective on AI assessed by Allen Newell and Herbert A. Simon:
</p>

<blockquote>
<p>
A physical symbol system has the necessary and sufficient means for general intelligent action, 
</p>
</blockquote>

<p>
With symbols, structures come naturally as list of symbols, and cognitive processes are understood as controlled by signal and symbol structures in <i>working memory</i>, i.e. arbitrary list structures in an extensive database-like system, sometimes called <i>goals</i>,  On the one hand, note the implicit analogy with the Turing machine model of a computer<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>, where perceptions are turned into symbols in memory, feeding a processor which elects further actions, operating changes in the environment. And, on the other hand, delineating further this analogy, the notions of symbol and list from which LISP, and all its functional programming languages descendants in computer science, was derived, and moreover by the same contributors to the seminal Dartmouth workshop<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>.
</p>

<p>
While the seminal ideas for the NXP Architecture stemmed from a very early interest in what would be now termed <i>learning concepts</i> (see <a href="#org08d0657">2</a>), they were readily influenced and refined by the dominant view at the time, all the more so that they matured in the cultural environment of Carnegie-Mellon University (CMU), namely of its Computer Science and Robotics Institute departments, from 1982 to 1984.
</p>
</div>
</div>

<div id="outline-container-org5c1472b" class="outline-3">
<h3 id="org5c1472b"><span class="section-number-3">1.2</span> Production Systems and Rule-based Systems</h3>
<div class="outline-text-3" id="text-1-2">
<p>
With the symbolic AI view then firmly entrenched, both in computer science and in the emerging philosophy of the mind, the idea of rule-based systems, in which <i>knowledge</i> is conventionally represented as <i>rules</i> operating on symbols (following the Physical Symbol System hypothesis) became an active applied research program.
</p>


<div class="figure">
<p><img src="./MODEL-HUMAN-PROCESSOR-w200.jpg" alt="MODEL-HUMAN-PROCESSOR-w200.jpg" />
</p>
<p><span class="figure-number">Figure 1: </span>Model Human Processor in <i>The Psychology of Human-computer Interaction</i>, by Card, Newell, Moran (1983). The brain-as-a-computer metaphor in the philosophy of the mind, all quantified!</p>
</div>

<p>
Although rule-based computation was originally used for formal and systems purposes , researchers in Artificial Intelligence (AI) found that the same methodology was also useful for modeling a wide variety of sophisticated tasks.
</p>

<blockquote>
<p>
The production system was one of those happy events, though in minor key, that historians of science often talk about: a rather well-prepared formalism, sitting in wait for a scientific mission. Production systems have a long and diverse history. Their use in symbolic logic starts with Post,  from whom the name is taken. They also show up as Markov algorithms,  Their use in linguistics, where they are also called rewrite rules, dates from Chomsky,  As with many other notions in computer science, they really entered into wide currency when they became operationalized in programming languages, first in string manipulation systems and in compiler translation languages,  Thus they were at hand when the data on human problem solving finally took a form (Problem Behavior Graphs) that pointed to their usefulness, 
</p>
</blockquote>

<p>
As commented on by Lenat<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup>, there were many design constraints present in the classical formal rule based systems. Many of these details were preserved in the AI production rule based programs (e.g., forcing all state information into a single string of tokens). But there were also many changes. The whole notion of &ldquo;what a rule system really is&rdquo; changed from an effective problem statement to a tendency to solve problems in a particular way. One typical corollary of this change of view was that instead of no external inputs whatsoever, there was now a presumption of some &ldquo;environment&rdquo; which supplied new entries into the token sequence.
</p>

<p>
So over the 1970s symbolic AI research mostly worked with rule systems (RS), a collection of condition-action rules, together with associated data structures (DS; also called memories, or <i>working memory</i>) which the rules may inspect and alter. There must also be a policy for <i>interpretation</i>: detecting and firing relevant rules (also known as <i>recognize-act-cycle</i>, later called <i>inference engine</i>). &ldquo;Intelligence is ten million rules,&rdquo; <a href="https://www.wired.com/2016/03/doug-lenat-artificial-intelligence-common-sense-engine/">Lenat pronounced in 1988</a>, such were the times.
</p>
</div>

<div id="outline-container-org24b1eca" class="outline-4">
<h4 id="org24b1eca"><span class="section-number-4">1.2.1</span> Neo-classical Rule System Architecture</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
In ten loose principles according to Lenat and Harris:
</p>

<dl class="org-dl">
<dt>Principle of Simple Memories</dt><dd>One or two uniform data structures define sufficient memories for a rule system to read from and write into. The format for entries In these structures is both uncomplicated and unchanging.</dd>
<dt>Principle of Simple DS Accesses</dt><dd>The primitive read and write operations are as simple and low-level as possible; typically they are simply a membership or equality test type of read, and an insert-new-element or set-value type of write. More complicated, algorithmic operations on the memories are not available to the rules.</dd>
<dt>Principle of Isolated DS Elements</dt><dd>Elements of the uniform DS cannot point to (parts of) other elements. This follows from the preceding principle: If we aren&rsquo;t allowed to chase pointers, there may as well not be any.</dd>
<dt>Principle of Continuous Attention</dt><dd>In addition to the one or two simple data structures, there may be an external environment which continuously inserts stimuli into the DS. The interleaving of stimuli and internally generated symbols is managed quite trivially: (a) The stimuli are simply inserted into the DS as new or changed elements; (b) Each rule is so small and quick that no &ldquo;interruption&rdquo; mechanism is necessary. The interpreter may ignore any suddenly-added stimulus until the current rule finishes executing. The RS may be viewed as &ldquo;continuously&rdquo; attending to the environment.</dd>
<dt>Principle of Opaque Rules</dt><dd>Rules need not have a format inspectable by other rules, but rather can be coded in whatever way is convenient for the programmer and the rule interpreter; i.e., the set of rules is not treated as one of the RSs data structures. E.g., the condition parts of rules may be barred from fully analyzing the set of productions, and the action parts of rules may not be allowed to operate on existing rules.</dd>
<dt>Principle of Simple Rules</dt><dd>Rules consist of a left- and a right-hand side which are quite elementary. The left hand side (lhs, situation characterization, IF-part, condition) is typically a pattern-match composed with a primitive DS read access, and the right hand side (rhs, consequence, THEN-part, action) is also simply a primitive DS write access. There is no need for sophisticated bundles of DS accesses on either side of a rule. Thus several extra rules should be preferred to a single rule with several actions.</dd>
<dt>Principle of Encoding by Coupled Rules</dt><dd>A collection of interrelated rules is used to accomplish each subtask; i.e., wherever a subroutine would be used in a procedural programming language. For example, programming an iteration may require many rules &ldquo;coupled&rdquo; by writing and reading special (Le., otherwise meaningless) loop control notes in the data structure.</dd>
<dt>Principle of Knowledge as Rules</dt><dd>All knowledge of substance should be, can : be, and is represented as rules. This includes all non-trivial domain dependent information. The role of the DS is just to hold simple descriptive information, intermediate control state messages, recent stimuli from the environment, etc.</dd>
<dt>Principle of Simple Interpretation</dt><dd>The topmost control flow in the RS is via a simple rule interpreter. After a rule fires, it is essential that any rule in the system may potentially be the next one to fire (i.e., it is forbidden to locate a set of relevant rules and fire them off in sequence). When the rhs of a rule is executed, it can (and frequently will) drastically alter the situation that determined which rules were relevant.</dd>
<dt>Principle of Closure</dt><dd>The representations allowed by (1-9) are sufficient and appropriate for organizing all the kinds of knowledge needed for tasks for which a given RS is designed.</dd>
</dl>

<p>
Notice the common theme: the adequacy of simplicity in all dimensions. 
</p>

<p>
Medical consultation as a task environment.
</p>
</div>
</div>

<div id="outline-container-org4069604" class="outline-4">
<h4 id="org4069604"><span class="section-number-4">1.2.2</span> Rules are put to many uses in inference</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
In contrast, defending that thinking may be more than computing<sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>, Peter Kugel refers to Peirce&rsquo;s definitions of:
</p>

<dl class="org-dl">
<dt>Rule</dt><dd>a general principle that is applied to specific examples. The analogy to a program representing an principle that computers apply to certain inputs still stands.</dd>
<dt>Case</dt><dd>what the rule is applied to. This would be the input in the computer program metaphor, or the working memory in the rule system.</dd>
<dt>Result</dt><dd>what is produced by the rule application. This would be the output in the computer program metaphor, or the effects of RHS actions on the working memory in a rule system.</dd>
</dl>

<p>
The overall analogy suggests that deduction might be modeled as evaluating a rule against case, which was often done at that time. While in logic, axiomatic theories are often thought as recursively enumerable (i.e. partially computable) theorems, here it is suggested that induction works from case and result to rule. And indeed, in the heydays of symbolic AI, Machine Learning research went this way,  years before the massive connectionist architecture of today&rsquo;s ML took up the prize.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">DEDUCTION</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Given:</td>
<td class="org-left">Rule: All men are mortal</td>
</tr>

<tr>
<td class="org-left">Given:</td>
<td class="org-left">Case: (SOCRATES IS-A MAN)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Concludes:</td>
<td class="org-left">Result: (SOCRATES IS-A MORTAL)</td>
</tr>
</tbody>
</table>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">INDUCTION</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Given:</td>
<td class="org-left">Case: (SOCRATES IS-A MAN)</td>
</tr>

<tr>
<td class="org-left">Given:</td>
<td class="org-left">Result: (SOCRATES IS-A MORTAL)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Concludes:</td>
<td class="org-left">Rule: All men are mortal</td>
</tr>
</tbody>
</table>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">ABDUCTION</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Given:</td>
<td class="org-left">Rule: All men are mortal</td>
</tr>

<tr>
<td class="org-left">Given:</td>
<td class="org-left">Result: (SOCRATES IS-A MORTAL)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Concludes:</td>
<td class="org-left">Case: (SOCRATES IS-A MAN)</td>
</tr>
</tbody>
</table>

<p>
Peirce&rsquo;s types of inference are related, but not identical to, notions of <i>forward-chaining</i> and <i>backward-chaining</i> in rule systems, which are later explored in the FUNXP architecture.
</p>

<p>
In the CMU culture, at the time, the &ldquo;neo-classical&rdquo; view defined by Lenat was prevalent. Its incarnation in the series of production systems languages, OPS, culminated in OPS 5 (and later OPS 83). OPS 5 was made instantly famous by the then well-known significant success of a first industrial application: R1/XCON, an expert system to configure VAX Systems at DEC<sup><a id="fnr.6" class="footref" href="#fn.6">6</a></sup>.
</p>


<div class="figure">
<p><img src="./OPS_series.png" alt="OPS_series.png" />
</p>
<p><span class="figure-number">Figure 2: </span>The OPS series of production systems languages. Source: Wikipedia, CC0, <a href="https://en.wikipedia.org/w/index.php?curid=44903117">https://en.wikipedia.org/w/index.php?curid=44903117</a></p>
</div>

<p>
In OPS-based expert systems, creation/update/deletion operations on the working memory were propagated into a graph, compiled from the rules. These changes triggered LHSes, concurrently selecting rules which could be fired at each step. The recognize-act-cycle parameters would drive picking up the rule(s) to fire, executing their RHSes and cycling back to rule selection<sup><a id="fnr.7" class="footref" href="#fn.7">7</a></sup>.
</p>

<p>
The numerous active developments, at CMU, about and around OPS 5 added to the design mix of the NXP Architecture. They helped contrasting and focusing on the proper interaction of backward chaining and forward chaining, that guide the logical process of rule evaluation.
</p>
</div>
</div>

<div id="outline-container-orgb7fbf1e" class="outline-4">
<h4 id="orgb7fbf1e"><span class="section-number-4">1.2.3</span> Rules with and without symbols</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
Interestingly, the formidable development of neurosciences and computational neurosciences in the last decades throws a new contemporary light on the venerable rule system thread of symbolic AI. Based on mathematical-logic and computer-science inspired metaphors, the rule system ended up as a model of a fundamental human cognitive faculty: the capacity for cognitive control, the ability to behave in accord with rules, goals or intentions (all problematic notions to the philosophy of mind, by the way) &#x2013; even when this runs counter to reflexive or other compelling competing responses.
</p>

<p>
A hallmark of this cognitive control is its remarkable flexibility. Novel tasks can be performed with very little additional experience (a problematic issue, in contrast, for the current &#x2013; 2021 &#x2013; crop of massive Deep Learning connectionist architectures). This was unfalteringly explored over several decades by, among others, Allen Newell,  then 
</p>

<p>
Today&rsquo;s neurosciences tell us that this ability appears to depend on the prefrontal cortex (PFC). This capacity, however, emerges only slowly over a protracted period through late adolescence. The rule system abstractly models flexible cognitive control at the psychological level, in terms of symbol processing computations that all support arbitrary variable bindings. A symbol may stand for anything, as computations only rely on the syntactic properties of such symbols<sup><a id="fnr.3.100" class="footref" href="#fn.3">3</a></sup>. It remains unclear, however, whether or how this model relates to the increasingly growing body of knowledge about the neural mechanisms underlying cognitive control and namely the functioning of the PFC.
</p>

<p>
At the biological level, many models were developed of cognitive control relying on the maintenance of rule-like representations in the PFC. But questions about how these representations develop and why this development should be so long are still unanswered,  Leveraging today&rsquo;s successes in massive connectionism, as is apparent in Deep Learning, neural networks models of the PFC can be trained to show development of rule-like task representations, which support generalization of task performance to novel environments. A perfect, modern instance of the proper treatment of connectionism, the approach pioneered more than thirty years ago that sought to set up &ldquo;check and balances&rdquo; strategies against an all-encompassing symbolic AI, 
</p>
</div>
</div>
</div>

<div id="outline-container-orgc595062" class="outline-3">
<h3 id="orgc595062"><span class="section-number-3">1.3</span> Clinical Consultation as a Task Environment</h3>
<div class="outline-text-3" id="text-1-3">
<p>
The third historical ingredient in the context for the original design in the NXP Architectures were some seminal applications of symbolic AI to Medicine, and more specifically to clinical consultation.
</p>
</div>

<div id="outline-container-org4198827" class="outline-4">
<h4 id="org4198827"><span class="section-number-4">1.3.1</span> Old and Long History of Medical Applications of AI</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
In 1956, Dr François Paycha presented a paper at the <i>Premier Congrès International De Cybernétique</i>, in Namur, on &ldquo;Cybernétique de la consultation&rdquo;, 
</p>

<p>
Inspired by the Weaver-Shannon information theory and Norbert Wiener&rsquo;s Cybernetics, &ldquo;Consultation Cybernetics&rdquo; is a full-fledged theory of heuristics in medical diagnosis. Useful abstractions in the logical process of reaching a positive diagnosis are precisely defined in an inclusive sequence of sets of signs/symptoms, syndrome, clinical pictures, and finally diseases, joined by typed links, which may be directed or not. The &ldquo;working memory&rdquo; was then represented as a graph:
</p>


<div class="figure">
<p><img src="./PAYCHA.jpg" alt="PAYCHA.jpg" />
</p>
<p><span class="figure-number">Figure 3: </span>Medical Consultation: a view from cybernetician Dr François Paycha, in 1956.</p>
</div>

<p>
Paycha suggests that &ldquo;diagnosis machines&rdquo; are needed to confront the increasingly growing volume of medical knowledge, already escaping the MD&rsquo;s comprehension. And diagnosis being only the first in a series of steps leading to prescription, and a healthy patient, the need is amplified by the increasing volume of therapeutics information.
</p>

<p>
The graph is traversed by the consultation exploratory process in three consecutive phases, termed <i>semiological</i>, <i>differential</i>, and <i>positive</i> diagnosis, respectively. Based on a form of ternary logic, <i>true</i>, <i>false</i>, and <i>unknown</i>, the first two phases range from signs/symptoms up to candidate diseases through syndromes and their related clinical pictures. Then a directed ternary-logic evaluation of the candidates is performed in the last phase, reaching one, or possibly several, positive diagnoses.
</p>

<p>
The theory articulates a data-driven phase, reminiscent of or heralding forward-chaining in rule systems, which Paycha insists is almost reflexive in the MD&rsquo;s mind &#x2013; thus also evocative of so-called spontaneous computations models studied twenty years later in computer science,  &#x2013; with a form of deductive backward-chaining goal and subgoal evaluation.
</p>

<p>
All the basic building blocks of AI in Medicine (AIM) were in place.
</p>
</div>
</div>

<div id="outline-container-orgc0f05e0" class="outline-4">
<h4 id="orgc0f05e0"><span class="section-number-4">1.3.2</span> There Were Many, Many Inspiring Accomplishments in AIM</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
The early ground-breaking AIM systems were developed by inspired pioneers at Stanford, Pittsburgh University, Rutgers, MIT and a few other innovative centers of AI research in the seventies. These were designed by collaborative teams where computer scientists, MDs and hospitals all worked together, against a background of more traditional approaches to the use of computer in clinical medicine, :
</p>

<dl class="org-dl">
<dt>Flowchart</dt><dd>or <i>clinical algorithm</i> which encodes, in principle, the sequences of actions a good clinician would perform for any one of some population of patients.</dd>
<dt>Data Bases</dt><dd>(in two separate words, at the time) enabling, when data is properly captured, the <i>matching</i> of cases to a large body of previous cases.</dd>
<dt>Application of Decision Theory</dt><dd>a mathematical theory of decision making under uncertainty, rooted in operations research.</dd>
</dl>

<p>
which were all thought as lacking the flexibility required for full-fledged <i>usable</i> clinical systems.
</p>

<p>
This crop of first generation programs proved over time to be inspiring accomplishments for later research:
</p>

<dl class="org-dl">
<dt>CASNET</dt><dd>developed at Rutgers University by Kulikowski, in its major instanciation as a diagnostic and therapeutic program for glaucoma and related diseases of the eye. EXPERT, a somewhat simpler descendant was more widely applied mostly in the analysis of thyroid disorders and rheumatology. It identified the fundamental issue of <i>causality</i> as essential in the diagnostic and used <i>causal-associational networks</i> as the core knowledge representation.</dd>
</dl>
<dl class="org-dl">
<dt>MYCIN</dt><dd>or as described by their developers Buchanan and Shortliffe, the series of MYCIN Experiments, at Stanford University, originally applied in the diagnosis and treatment of bacterial infections of the blood. Rules famously represent knowledge in MYCIN, often associated with so called <i>certainty factors</i>.</dd>
</dl>
<dl class="org-dl">
<dt>Digitalis Therapy Advisor</dt><dd>developed at MIT by Szolovits <i>et al.</i>, where knowledge is captured in Minsky&rsquo;s <i>frames</i> model he suggested for memory structures.</dd>
</dl>
<dl class="org-dl">
<dt>INTERNIST</dt><dd>developed at the University of Pittsburgh by Pople, an ambitious program for diagnosis in general internal medicine. Special emphasis on the distinction between problem formulation and problem solving, a characteristic of this system, was further refined in CADUCEUS, a follow-on system in the mid-80s.</dd>
</dl>
<dl class="org-dl">
<dt>PIP</dt><dd>designed, at MIT, to emulate clinicians in the evaluation of patients with renal disease. It merged facts about the patient with knowledge from a database to develop a hypothesis about what was afflicting the patient. More complex cases were addressed by ABEL (by Patil), a program for the diagnosis, and eventual treatment, of acid/base and electrolyte disturbances.</dd>
</dl>

<p>
Started in 1972 at Stanford University, MYCIN is a pioneering computer-based consultation system designed to assist physicians in the diagnosis of and therapy selection for patients with bacterial infections. In addition to the consultation system itself, MYCIN contains an explanation system which can answer simple English questions in order to justify its advice or educate the user. The system&rsquo;s knowledge is encoded in the form of some 350 production rules which embody the clinical decision criteria of infectious disease experts. Much of MYCIN&rsquo;s power derives from the modular, highly stylized nature of these decision rules, enabling the system to dissect its own reasoning and allowing easy modification of the knowledge base, 
</p>


<div class="figure">
<p><img src="./MYCIN.jpg" alt="MYCIN.jpg" />
</p>
<p><span class="figure-number">Figure 4: </span>The MYCIN Experiments at Stanford&rsquo;s SUMEX-AIM.</p>
</div>

<p>
Stanford&rsquo;s MYCIN and its descendants, such as EMYCIN<sup><a id="fnr.8" class="footref" href="#fn.8">8</a></sup>, a domain independent version of MYCIN for use in other domain and applications, and ONCOCIN<sup><a id="fnr.9" class="footref" href="#fn.9">9</a></sup>, an oncology protocol management system designed to assist physicians in the treatment of cancer patients, had a long-lasting influence on the whole program of AI research and precipitated the commercial the early eighties charge towards industrial and commercial applications of expert systems.
</p>

<p>
Predominantly based on backward-chaining, in contrast to the design of CMU&rsquo;s OPS series of production system languages, MYCIN nonetheless fixed the major features and definitions of expert systems, and <i>expert system shells</i> as domain-independent <i>knowledge engineering</i> software tools.
</p>

<p>
In 1983, Ed Shortliffe reflected on the impact of MYCIN on AI:
</p>

<blockquote>
<p>
You mentioned earlier that MYCIN is often cited as sort of the fundamental expert system &#x2013; which may be overstating the case for MYCIN. DENDRAL is certainly the earliest really well-accepted expert system, although it has some different elements . It&rsquo;s not interactive for large groups of people in quite the same way that MYCIN is intended to be . But ideas that grew out of MYCIN and
DENDRAL and other medical efforts such as the CASNET project at Rutgers, the INTERNIST project at the University of Pittsburgh, work at MIT on a program called PIP (the Present Illness Program), and subsequent work at MIT on explanation and more recently causal reasoning and multi-level causal descriptions, have contributed greatly to the state of the art in expert systems and, in turn, to the demonstration of these ideas.
</p>
</blockquote>

<p>
MYCIN made popular constructs like <i>rule interpreters</i> (shells) and <i>rule compilers</i> (in this case to decision trees) and <i>certainty factors</i>; main control structure as goal-directed backward chaining of rules<sup><a id="fnr.10" class="footref" href="#fn.10">10</a></sup>; interactivity by asking questions to the user, modularity of rules which could be edited individually; explanation capabilities. (Note that early expert systems faced the same critic, which are today addressed to ML Deep Learning neural nets, of demanding <i>explanation</i> for the conclusions it reached in order to be accepted as a legitimate tool by a community of practitioners.)
</p>


<div class="figure">
<p><img src="./EXPERT-SYSTEM.jpg" alt="EXPERT-SYSTEM.jpg" />
</p>
<p><span class="figure-number">Figure 5: </span>The Expert System Architecture industry standard in the late eighties.</p>
</div>


<p>
Its influence was certainly important on the NXP Architecture as its first demonstration knowledge bases, for research purposes, were all from the medical consultation task environment  Closer to the CMU campus, INTERNIST-I was a broad-based computer-assisted diagnostic tool developed in the early 1970s at the University of Pittsburgh as an educational experiment<sup><a id="fnr.11" class="footref" href="#fn.11">11</a></sup>.
</p>

<p>
In hindsight, the NXP Architecture design strongly benefited from the accomplishments of this opening chapter of AIM, <sup><a id="fnr.12" class="footref" href="#fn.12">12</a></sup>  These stepping stones were retrospectively described in 2015 by Pr. Casimir Kulikowski, whose doctoral dissertation, in 1970, described a pattern recognition model which has been successfully used to simulate a doctor&rsquo;s diagnostic process:
</p>

<blockquote>
<p>
During the first half of the 1970’s, several groups working on computational models for clinical decision-making and problem-solving had developed the MYCIN rule-based system for infectious disease therapy assistance at Stanford, the CASNET Causal Associational NETwork model for consultation in glaucoma, at Rutgers, the DIALOG (later renamed INTERNIST) system for differential diagnosis in internal medicine at Pittsburgh, and the PIP (Present Illness Program)
for diagnosis-driven acquisition of clinical data at MIT and Tufts. These had been inspired by AI approaches that departed from the earlier general problem solving search paradigm characteristic of AI since its inception and still holding sway into the 1970’s, and focused on capturing domain- and problem-specific strategies for solving complex sequences of expert biomedical interpretations and actions. These included the rule-based and hypothesis-list approaches used in the DENDRAL Project, which influenced MYCIN, as well as
experimental, instructional, interview-based, and cognitive approaches to the analysis of clinical problem solving, and the causal-taxonomic representation of underlying processes of disease.  While earlier computer models for medical decision-making were predominantly statistical or algorithmic, the new AI approaches developed structured representations of specific clinical domain knowledge over which a general inference engine could reason with a variety of heuristics, and provide advice or suggestions to the consulting user.
</p>
</blockquote>


<div class="figure">
<p><img src="./CASNET.jpg" alt="CASNET.jpg" />
</p>
<p><span class="figure-number">Figure 6: </span>Strategies in CASNET glaucoma consultation program, developed at Rutgers (1971-8) based on <i>causal association networks</i>.</p>
</div>

<p>
Closing the loop with the early cybernetics endeavors in Medicine of Dr Paycha, the state of the art of AI systems for medical consultation was summarized in computer programs such as NEOMYCIN. Revisiting the &ldquo;MYCIN experiments&rdquo; over close to twenty years, and reconfiguring the system for education purposes &#x2013; the ultimate use INTERNIST-I was also put to at about the same time &#x2013; the following diagram was published:
</p>


<div class="figure">
<p><img src="./MYCIN-STRATEGY.jpg" alt="MYCIN-STRATEGY.jpg" />
</p>
<p><span class="figure-number">Figure 7: </span>Strategies in MYCIN-inspired medical consultation computer programs.</p>
</div>

<p>
Note the similarities with Dr Paycha&rsquo;s investigations of 1956, allowing for changes in terminology and some refinements on the pedagogical aims of the classification.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org08d0657" class="outline-2">
<h2 id="org08d0657"><span class="section-number-2">2</span> How we got here</h2>
<div class="outline-text-2" id="text-2">
<p>
The functional perspective motivates revisiting &#x2013; once more &#x2013; the design of the NXP Architecture. This section elaborates on what is expected of functionalism (as in the philosophy of mind) or of functional languages when it comes to the nature and implementation of the NXP Architecture.
</p>
</div>

<div id="outline-container-org70f0bae" class="outline-3">
<h3 id="org70f0bae"><span class="section-number-3">2.1</span> NXP Archeology and vestigial software artifacts</h3>
<div class="outline-text-3" id="text-2-1">
<p>
The seminal ideas, presented in context in the <a href="#org1520ea4">1</a> slowly matured over time. Several computer programs, designed as scientific experiments on a computer model of the mind, in typical Newell-Simon style, testify to the long trek in the design space that brought us here and now.
</p>

<dl class="org-dl">
<dt>PHILIPS</dt><dd>Associative memory; exploration of clustering in Machine Learning (1979-80).</dd>
<dt>NCLOSE</dt><dd>An AIM inference engine with a focus on differential diagnosis in medical consultation (1982-3). Also Rappaport, A., <i>Closed Search: an hypothesis evaluator</i>, Unpublished manuscript, Robotics Institute, Carnegie-Mellon University, (1982).</dd>
<dt>KAA</dt><dd>Derived from PHILIPS, ML by clustering on the inference paths of the NCLOSE performances (1982-3).</dd>
<dt>SCS</dt><dd>A knowledge management tool for the KAS/PROSPECTOR rule model, written in OPS 5 (1982-3). Also Mulsant, B., Servan-Schreiber, D. <i>A Gentle Introduction to Artificial Intelligence in Medicine</i>. Unpublished manuscript, Robotics Institute, Carnegie-Mellon University, (1982).</dd>
<dt>PROSYL</dt><dd>Nclose-inspired algorithm for many-objects many-patterns matching à la RETE (1983).</dd>
<dt>AMBER</dt><dd>Generalizing previous programs: discovery and clustering of sequential observations for prediction (1984).</dd>
<dt>NEXPERT, later NEXPERT OBJECT</dt><dd>Industry-standard expert system development environment on microcomputers, workstations and mainframes, with pioneering GUI (1985-)</dd>
</dl>

<p>
Recent, and mostly unpublished, research work explored further implementations and design ideas about the NXP Architecture:
</p>

<dl class="org-dl">
<dt>Theoretical models</dt><dd>Expressing heuristics in continuation passing style (CPS) <a href="https://arxiv.org/abs/cs/0211035">Monadic Style Control Constructs for Inference Systems</a> (2002), <a href="https://arxiv.org/abs/cs/0402035">Memory As A Monadic Control Construct In Problem-Solving</a> (2004).</dd>
<dt>NClosEmacs</dt><dd>A Nclose-inspired rule/hypothesis evaluator written in Emacs-Lisp with a Machine Learning (ML) extension exploring <i>bagging</i> and <i>boosting</i> (2008-10).</dd>
<dt>LLVM-based implementation</dt><dd>Based on CLANG, CouchDB and a minimal GUI client in GTK+, a NXP Architecture based on CPS constructs (2010).</dd>
<dt>Micro-Service implementation</dt><dd>Written in Javascript and based on Node, Moleculer, the progressive microservice framework, a demonstration prototype with a React GUI (2018) for the Web.</dd>
</dl>
</div>
</div>

<div id="outline-container-org78f0fa5" class="outline-3">
<h3 id="org78f0fa5"><span class="section-number-3">2.2</span> Meanwhile functionalism thrives in the philosophy of mind</h3>
<div class="outline-text-3" id="text-2-2">
<p>
In the philosophy of mind, functionalism is generally considered one of the major proposals that have been offered as solutions to the mind/body problem<sup><a id="fnr.13" class="footref" href="#fn.13">13</a></sup>.  Functionalism says that mental states are constituted by their causal relations to one another and to sensory inputs and behavioral outputs.  
Functionalism is one of the major theoretical developments of Twentieth Century analytic philosophy, and provides the conceptual underpinnings of much work in cognitive science.
</p>

<p>
Ned Block lists three sources for functionalism:
</p>

<blockquote>
<ul class="org-ul">
<li>Putnam and Fodor saw mental states in terms of an empirical computational theory of the mind<sup><a id="fnr.3.100" class="footref" href="#fn.3">3</a></sup>. (A critical assumption in the symbolic v. connectionism recurring debate, where both sides appeal to a form of computation.)</li>
<li>Smart&rsquo;s &ldquo;topic neutral&rdquo; analyses led Armstrong and Lewis to a functionalist analysis of mental concepts. (In which <i>causality</i> is emphasized<sup><a id="fnr.14" class="footref" href="#fn.14">14</a></sup>.)</li>
<li>Wittgenstein&rsquo;s idea of <i>meaning as use</i> led to a version of functionalism as a theory of meaning, further developed by Sellars and later Harman.</li>
</ul>
</blockquote>

<p>
Leveraging the mind-as-computer metaphor (see <a href="#orgb7fbf1e">1.2.3</a>), Block introduces the function relevant to mind by way of the Turing machine. What is a state of a Turing machine? Its nature is entirely relational: the state is completely defined by its relation with other states in the transition table. And so:
</p>

<ul class="org-ul">
<li>According to functionalism, the nature of a mental state is just like the nature of an automaton state: constituted by its relations to other states and to inputs and outputs;</li>
<li>Hence mental states can be totally characterized in terms that involve only logico-mathematical language and terms for input signals and behavioral outputs. (A syntactic view of characterizing mental processes.)</li>
<li>Mental states, however, do have <i>other</i> (e.g. physical) properties. These other properties are said to be the <i>realizations</i> of the functional properties. So, although functionalism characterizes the mental in non-mental terms, it does so only by quantifying over realizations of mental states (which would not have delighted behaviorists).</li>
<li>Of course then, one functional state can be realized in different ways. (This, we saw, is a principle in the symbolic AI approach which abstracts the underlying substrate for mental processes.)</li>
<li>Conversely, one physical state can realize different functional states in different machines, including the brain.</li>
</ul>

<p>
Functionalism then permeates cognitive science and AI<sup><a id="fnr.15" class="footref" href="#fn.15">15</a></sup> since inception. It hints at the the falsity of physicalism:  if a creature without a brain can think, thinking can&rsquo;t be a brain state<sup><a id="fnr.5.100" class="footref" href="#fn.5">5</a></sup>.
</p>

<p>
The issue of realization is not without difficulty, however. Should we consider it in empirical psychology and functionalism aims at capturing mental concepts (as ordinarily understood); should we consider it in common sense psychology, and functionalism aims rather at fixing the extension of mental terms. (Reminiscent of distinctly&#x2013;and non equivalently&#x2013;defining a function in the mathematical sense, by extension, or by intension.) These variants of functionalism in turn spell different problems in relating mental states to causation, or to <i>qualia</i> (phenomenal states like the look of <i>red</i>)<sup><a id="fnr.16" class="footref" href="#fn.16">16</a></sup>.
</p>
</div>
</div>

<div id="outline-container-org38cbee7" class="outline-3">
<h3 id="org38cbee7"><span class="section-number-3">2.3</span> And functional programming languages in computer science</h3>
<div class="outline-text-3" id="text-2-3">
<p>
As mentioned before, the roots of the symbolic AI and functional programming languages are historically intertwined, dating back to the Dartmouth workshop of 1956. And so, at different times in its history, AI was just equated with LISP programs and LISP-Machines, LISP being the original and archetype functional programming language. In computer science, functional programming is a programming paradigm where programs are constructed by applying and composing functions. (In this respect, it shares some principles with versions of functionalism in the philosophy of mind glossed over in <a href="#org78f0fa5">previous section</a>.) 
</p>


<p>
It is a declarative programming paradigm in which function definitions are trees of expressions that each return a value, rather than a sequence of imperative statements which change the state of the program. In this respect, it naturally blends with declarative knowledge, <a href="#org5c1472b">rule systems</a>.
</p>


<p>
As an exploration path for this research project, we planned to revisit this blending of symbolic processes perspectives, viewed as mental processes and viewed as computer programs expressed in functional languages, leading to an original (re)implementation of the NXP Architecture.
</p>
</div>

<div id="outline-container-orgc281939" class="outline-4">
<h4 id="orgc281939"><span class="section-number-4">2.3.1</span> Evaluation, Compilation and Abstract Machines</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
A solid trend in programming language design has been the use of operational semantics to define the semantics of a programming language. In this respect, Abstract machines have been effectively used as intermediate and low-level architectures suitable for supporting serious implementations of a wide variety of programming languages, including imperative, functional, and logic programming languages. Abstract machines are distinguished from operational
semantics by having simple and direct algorithmic implementations that can employ efficient data structures. On the other hand, abstract machines are distinguished from lower-level, machine-code implementations because typically the former uses pattern matching for manipulating data while the latter explicitly addresses the notions of structure sharing, storage allocation, and register allocation<sup><a id="fnr.17" class="footref" href="#fn.17">17</a></sup>. 
</p>

<p>
In the above characterization of abstract machines their use as an intermediate language for compilation is an essential feature. As a result the implementation of a programming language consists of two stages. The implementation of the compiler and the implementation of the abstract machine<sup><a id="fnr.18" class="footref" href="#fn.18">18</a></sup>. These two consecutive stages are the path we followed to build this project of NXP Architecture with a functional perspective. Both the abstract machine implementation and the original compiler implementation are in Emacs-Lisp.
</p>

<p>
In writing the compiler, care was exercised in order to only peruse the subset of Emacs-Lisp that maps directly into the primitives of the functional language, a simple variant of LISP called <code>funx</code>. By doing so, the compiler may compile itself to the <code>funx</code> abstract machine, so that further developments no longer require the original compiler source.
</p>

<p>
Additionally, the abstract machine can be ported to other programming languages with minimal effort&#x2013;C, Python or Javascript being interesting targets for such ports.
</p>

<p>
Along the development of computer science abstract machines were designed and developed for imperative programming languages (Algol Object Code, UCSD P-Machine) later evolving towards abstract machines for object-oriented programming languages (Smalltalk-80, Self, Java VM). Abstract machines also abound in string processing languages<sup><a id="fnr.19" class="footref" href="#fn.19">19</a></sup>.
</p>

<p>
Abstract machines were also created for functional programming languages. The first abstract machines for functional languages, such as the SECD,  and FAM, defined strict evaluation, also known as eager or call-by-value evaluation, in which function arguments are evaluated before the call, and exactly once. More recently, most work has focused on lazy (or call-by-need) evaluation, in which function arguments are evaluated only if needed, and at most once.
</p>

<p>
Central concepts in abstract machines for functional languages include:
</p>
<dl class="org-dl">
<dt>A stack</dt><dd>represents the context of a nested computation. It may hold the intermediate results of pending computations, activation records of active function invocations, active exception handlers, etc.  The stack is sometimes used also for storing arguments to be passed to functions.</dd>
</dl>
<dl class="org-dl">
<dt>An environment</dt><dd>maps program variables to their values.</dd>
</dl>
<dl class="org-dl">
<dt>A control list</dt><dd>a sequence of controls to be executed later, representing the rest of the calculation, also called a <i>continuation</i>. Each control is simply an operation that transforms the state of the abstract machine into a new state (in perfect Turing style).</dd>
</dl>
<dl class="org-dl">
<dt>A closure</dt><dd>is used to represent a function as a value.  It typically consists of a code address (for the function body) and an environment (binding the free variables of the function body)&#x2013;more on closures later.</dd>
</dl>
<dl class="org-dl">
<dt>A heap (dump)</dt><dd>stores the data of the computation. Abstract machines usually abstract away from the details of memory management, and thus include instructions for allocating data structures in the heap, but not for freeing them; the heap is assumed to be unlimited.</dd>
</dl>
<dl class="org-dl">
<dt>A garbage collector</dt><dd>supports the illusion that the heap is unlimited; it occasionally reclaims unreachable heap space and makes it available for allocation of new objects.</dd>
</dl>

<p>
The SECD machine (1964) was designed by Landin for call-by-value evaluation of the pure lambda calculus,  Although there are many evolved abstract machines later developed for increasingly richer and more expressive higher-function programming languages<sup><a id="fnr.20" class="footref" href="#fn.20">20</a></sup>, we chose to focus the initial design of the NXP Architecture Abstract Machine on this seminal model. The machine derives its name from the components of its state: an evaluation stack <i>S</i>, an environment <i>E</i>, a control <i>C</i> holding the instructions to execute, and a dump <i>D</i> holding a continuation (i.e., a description of what must be done next) and other data.
</p>

<p>
#+CINDEX Lispkit
</p>
<p>
Lispkit Lisp is a lexically scoped, purely functional subset of Lisp (&ldquo;Pure Lisp&rdquo;) developed as a testbed for functional programming concepts,  It was first used for early experimentation with <i>lazy evaluation</i>. An SECD machine-based implementation (written in an ALGOL variant) was published by the developer Peter Henderson in 1976, 
</p>

<p>
Henderson later published a reference book on functional programming languages and the SECD machine,  from which the design of this experimental NXP Architecture abstract machine heavily borrows. (Misunderstandings and bugs are, however, all mine!)
</p>
</div>
</div>

<div id="outline-container-org96fde80" class="outline-4">
<h4 id="org96fde80"><span class="section-number-4">2.3.2</span> Strict v. Lazy Evaluation</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
Two fundamental questions to the functional programming language implementor are:
</p>
<ul class="org-ul">
<li>How are function values, data values and unevaluated expressions represented?</li>
<li>How is function application performed?</li>
</ul>

<p>
Large chapters of Henderson&rsquo;s book detail answers to these questions in the context of the SECD model. As appropriate for a functional programming language, every expression in <code>funx</code> is represented as a <i>symbolic expression</i>, or <i>sexp</i>.
</p>

<p>
Note that an <i>intepreter</i> for a functional language like <code>funx</code> can be defined as a function itself <code>eval :: apply( &lt;F-SEXP&gt;, &lt;ARGS&gt; )</code> which basically expects a well-formed sexp, with a function value, and a list of its arguments. During interpretation, each well-formed sub-expression is identified and evaluated (often more than once). So the interpreter turns out to be a case analysis of the well-formed sub-expressions of a program.
</p>

<p>
Applying a function to its arguments is the <i>core binding operation</i> in <code>funx</code> and other functional programming languages. Every expression in <code>funx</code> is evaluated with respect to an environment. An environment is just that, this association between arguments and values (which are simply sexps). In the situation where the functional expression refers to variables introduced, not as arguments to the application, but locally&#x2013;one also talks about variables defined outside the scope of the function&#x2013;the environment needs to be augmented with the bindings for these variables prior to evaluation. This is the role of the <code>let</code> primitive in <code>funx</code> which introduces blocks with additional bindings.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp" id="org3d49d36">(<span style="color: #F92672;">let</span>
    ((foo (<span style="color: #F92672;">lambda</span> (x) (add y (mul (<span style="color: #F92672;">quote</span> 2) x))))
     (y (<span style="color: #F92672;">quote</span> 4))
     )
  (foo (<span style="color: #F92672;">quote</span> 3))
  )
</pre>
</div>

<p>
In the example above, this block mechanism is used to introduce and name a new function in <code>funx</code>. The name <code>foo</code> is bound to a function value (a functional sexp). The function value is called a <i>closure</i>, a composite sexp which contains both the sexp for the function&#x2013;here the lambda expression&#x2013;and the environment defining the values of the variables (in this instance, <code>y</code>) and arguments (<code>x</code>) to the function. Finally the application sexp <code>(foo (quote 3))</code> is evaluated in an environment listing the binding of <code>foo</code> to this closure and the binding of <code>x</code> to the constant <code>3</code>. The evaluation produces the expected value <code>10</code>.
</p>

<p>
Note that in <code>funx</code> there is a single <code>let</code> primitive which plays the roles of both <code>let</code> and <code>letrec</code> in Lispkit. The block introduced by <code>let</code> may contain mutually recursive definitions.
</p>

<p>
In Cardelli&rsquo;s FAM, closure are represented as the text of the function and the value of its free variables. The text of a function is in itself a rather complex structure; it contains a sequence of instructions in some suitable machine language, and a set of literals which may be strings or other text cells. From a different perspective, in Henderson&rsquo;s SECD-based Lispkit, a function value is a suspended computation (promise to perform the computation when the value is applied to some arguments). The most compact way to represent a closure is as a block of static code (shared by all dynamic instances of the value), together with the values of its free variables.
</p>

<p>
In terms of implementation, the representation of closure could be:
</p>
<ul class="org-ul">
<li>A block of heap-allocated storage with one pointer to code followed by pointers to variables. The environment pointer points to the closure and variables are accessed by calls relative to this pointer. (Directly or by chains of pointers, with an impact on GC.)</li>
<li>The Three Instruction Machine (TIM) takes another interesting position<sup><a id="fnr.21" class="footref" href="#fn.21">21</a></sup>. Instead of representing a closure by a single pointer, it represents a closure by a pair of a code pointer and a pointer to a heap-allocated frame. The frame, which is a vector of code-pointer/frame-pointer pairs, gives the values of the free variables of the closure, and may be shared between many closures.</li>
</ul>

<p>
In this implementation in Emacs-Lisp, environments are simply represented as association lists  Closure are lists constituted of the list of arguments to the function, the control list (i.e. compiled code, since we are targeting a compiler) for the functional sexp, and the environment.
</p>

<p>
This closure infrastructure in the SECD machine is also critical in implementing <i>eager</i> evaluation or <i>lazy</i> evaluation we alluded to above. In eager, or strict, evaluation, sexps are evaluated immediately as they are mentioned (call-by-value). In a non-strict language evaluation, values are passed to functions or stored in data structures in unevaluated form, and only evaluated when their value is actually required (call-by-need). There is a long and rich literature on strict v. non strict functional languages, eager v. lazy (sometimes even <i>lenient</i>) interpreters and compilers:    
</p>

<p>
Like function values, these unevaluated forms capture a <i>delayed</i> computation, and can be represented by a closure in the same way as a function value. Following a broadly used terminology, we call this particular sort of closure a <i>thunk</i>, or a <i>promise</i>, a term which goes back to the early Algol implementations of call-by-name. When the value of the promise is required, the promise is <i>forced</i>, through naive reduction, cell model (flag) or self-updating model implementation, so that if the value is later required the value of this original evaluation is returned instead of being reevaluated. 
</p>

<p>
So using the same closure concept as above, sexp evaluations can be delayed (lazy) or forced without changing the sexp itself. In eager evaluation, sexps are never delayed (or always forced). Compilers from the Lisp tradition usually compile function application as follows: evaluate the function, evaluate the argument, and apply the function value to the argument. When a known function is being applied (as is often the case, especially in Lisp), the &ldquo;evaluate the
function&rdquo; part becomes trivial. This model for function application, which we called earlier the <i>eval-apply model</i>, is invariably used by compilers for strict languages (eg Lisp, Hope, SML and the SECD machine in Landin&rsquo;s and in Henderson&rsquo;s papers). It is also used in some implementations of non-strict languages, except that of course only the function is evaluated before the application (eg the ABC machine<sup><a id="fnr.22" class="footref" href="#fn.22">22</a></sup>, and the &lt;n,G&gt;-machine<sup><a id="fnr.23" class="footref" href="#fn.23">23</a></sup>).
</p>

<p>
In contrast, compilers based on lazy graph reduction treat function application as follows: push the argument on an evaluation stack, and tail-call (or enter) the function. There is no &ldquo;return&rdquo; when the evaluation of the function is complete. We call this the <i>push-enter</i> model.
</p>

<p>
Henderson gives a precise definition of lazy evaluation, based on the <code>delay</code> and <code>force</code> operations, in a purely functional program (usually without any delays or forces). The rules are written as a series of program transformations:
</p>
<ul class="org-ul">
<li>delay all arguments to (user-defined) functions</li>
<li>delay all arguments to <code>cons</code></li>
<li>delay all definitions in <code>let</code> blocks</li>
<li>repeatedly force all arguments to primitive functions other than <code>cons</code></li>
<li>repeatedly force the test sexp in conditional expressions</li>
<li>repeatedly force the function in a function application.</li>
</ul>

<p>

</p>

<p>
The power of lazy evaluation also allows the processing of potentially infinite structures and the proper interpretation of mutually recursive equations defined in <code>let</code> blocks. It also apply to the proper execution of a functional program viewed as a network of communicating processes,  This turns functional languages into particularly natural forms of expressions for certain types of parallelism (and in particular, <i>data driven</i>, which is particularly useful in <a href="#org5c1472b">rule systems</a>.
</p>

<p>
The next section of this manual will detail a SECD abstract machine, derived from Lispkit, with a strict compiler for the <code>funx</code> functional programming language. Henderson&rsquo;s transformations we be used however to design the <code>funxp</code> NXP-related extensions to the language as they require lazy compilation.
</p>
</div>
</div>

<div id="outline-container-orgcfaf55c" class="outline-4">
<h4 id="orgcfaf55c"><span class="section-number-4">2.3.3</span> I/O and GUI</h4>
<div class="outline-text-4" id="text-2-3-3">
<p>
Two chapters in Henderson&rsquo;s book explain how input-output for the Lispkit LISP variant is implemented on typical hardware. Depending on the underlying implementation hardware, mapping of the abstract machine may vary and primitives for the input and output of sexps are correspondingly required.
</p>

<p>
The choice of Emacs-Lisp as an implementation programming language (and execution model) frees us from these developments for the moment. Sexps are naturally parsed and printed out by the Emacs-Lisp machinery, and the abstract <code>funx</code> machine is mapped almost directly to the underlying Emacs interpreter. A follow on to this project would be to port the abstract machine to another environment (such as Javascript with Node.js), involving a new mapping of the abstract machine to the concrete one.
</p>

<p>
Consequently well-formed sexps for the <code>funx</code> language will be expressed here in (a subset of) Emacs-Lisp symbolic expressions.
</p>

<p>
Similarly, Emacs being the overall environment for this abstract machine its graphical user interfaces, and user experience, would primarily be text-based. The result <code>funxp</code> is both a programming language and an interactive programming environment,   for expert systems. It embeds NCLOSE, an earlier inference engine, in a simple&#x2013;even simplistic&#x2013;functional programming language called <code>funx</code> (<i>functional expressions</i>).
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org271f9cf" class="outline-2">
<h2 id="org271f9cf"><span class="section-number-2">3</span> A simplistic functional language, funx</h2>
<div class="outline-text-2" id="text-3">
<p>
This section is devoted to the exploration of the semantics of a simplified functional programming language, called <code>funx</code>, in which we later plan to embed a rule system, resulting in <code>funxp</code>, an implementation of the NXP Architecture with a functional perspective.
</p>

<p>
Moreover, we are interested in developing a compiler for <code>funx</code> and <code>funxp</code>. Hence after presenting the language itself, we describe the SECD-based abstract machine for the language and its implementation in Emacs-Lisp.
</p>
</div>

<div id="outline-container-org0e6d5a8" class="outline-3">
<h3 id="org0e6d5a8"><span class="section-number-3">3.1</span> FUNX a functional language, pure and simplistic</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Concrete <code>funx</code> programs are (Emacs-Lisp) sexps as per our design choices of implementation language and environment. The following sexps, where <code>s</code> is any sexp,  <code>x</code> are atoms and <code>e</code> well-formed expressions,  are <i>all</i> the well-formed expressions in <code>funx</code>:
</p>

<dl class="org-dl">
<dt><code>x</code></dt><dd>a variable.</dd>
</dl>
<dl class="org-dl">
<dt><code>(quote s)</code></dt><dd>a constant sexp.</dd>
</dl>
<dl class="org-dl">
<dt><code>(add e1 e2)</code>, <code>(sub e1 e2)</code>, <code>(mul e1 e2)</code>, <code>(div e1 e2)</code>, <code>(rem e1 e2)</code></dt><dd>arithmetic expressions (whose arguments are usually quoted when constant&#x2013;a difference with Emacs-Lisp).</dd>
</dl>
<dl class="org-dl">
<dt><code>(eq e1 e2)</code>, <code>(leq e1 e2)</code></dt><dd>equality and comparison tests, returns a <code>funx</code> boolean, special atoms <code>*T*</code> and <code>*F*</code>.</dd>
</dl>
<dl class="org-dl">
<dt><code>(car e)</code>, <code>(cdr e)</code>, <code>(cons e1 e2)</code></dt><dd>cell structure operations.</dd>
</dl>
<dl class="org-dl">
<dt><code>(atom e)</code></dt><dd>tests for atomicity, returns a <code>funx</code> boolean, special atoms <code>*T*</code> and <code>*F*</code>.</dd>
</dl>
<dl class="org-dl">
<dt><code>(if e1 e2 e3)</code></dt><dd>conditional form, where <code>e1</code> should evaluate to a <code>funx</code> boolean, special atoms <code>*T*</code> and <code>*F*</code>.</dd>
</dl>
<dl class="org-dl">
<dt><code>(lambda (x1 ... xN) e)</code></dt><dd>function definition, returns a function value.</dd>
</dl>
<dl class="org-dl">
<dt><code>(e e1 e2 ... eN)</code></dt><dd>function application, applies function <code>e</code> to arguments&rsquo; values <code>eI</code>.</dd>
</dl>
<dl class="org-dl">
<dt><code>(let ((x1 e1) ... (xN eN)) e)</code></dt><dd>recursive block, evaluates sexp <code>e</code> in the environment bindings <code>(x1 e1) ... (xN eN)</code>.</dd>
</dl>

<p>
These are the <code>funx</code> built-in functions supported by the abstract machine described in the next section. We will also see how this limited set of functions is nonetheless powerful enough to express its own compilers, eager and lazy. (It is also sufficient to express its own interpreter, should we want to skip the abstract machine step altogether.)
</p>

<p>
As an example of a program expressed in <code>funx</code>, we state the perennial factorial example and show below a possible sexp to compute <code>3!</code>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>The perennial factorial example, example <code>ex1.lsp</code>.</label><pre class="src src-emacs-lisp" id="orgba1900e">(<span style="color: #F92672;">let</span>
    ((fac
      (<span style="color: #F92672;">lambda</span> (n)
        (<span style="color: #F92672;">if</span> (eq n (<span style="color: #F92672;">quote</span> 1)) (<span style="color: #F92672;">quote</span> 1) (mul n (fac (sub (<span style="color: #F92672;">quote</span> 1) n))))))
     )
  (fac (<span style="color: #F92672;">quote</span> 3))
  )
</pre>
</div>

<p>
Variables are bound in <code>lambda</code> and <code>let</code> expressions. When their definitions are called their associated argument (in lambda-sexps) or local block definition (in let-sexps) are eagerly evaluated and new bindings are pushed into the environment. On exit of the function call or of the block, the variables, and their bindings in the environment are deleted. (Note that <code>let</code> in <code>funxp</code> is called <code>letrec</code> in Henderson&rsquo;s book.)
</p>

<p>
Note that using the environment both as an association list and as a stack simplifies the management of variables with identical names. The value retrieved is always the one bound in the most local binding, which is the first found when searching the environment.
</p>

<p>
Constants are always quoted&#x2013;a point of departure from the Emacs-Lisp convention of not quoting numbers. Operators are defined as prefix as is common in LISP so that <code>2 + 2</code> is expressed as <code>(add (quote 2) (quote 2))</code>.
</p>

<p>
Denotational semantics for Lispkit-Lisp and <code>funx</code> into the set category can be readily developed, leading to provably correct interpreters<sup><a id="fnr.24" class="footref" href="#fn.24">24</a></sup>. The classic difficulty is the semantics of the <code>let</code> recursive block operator. (The non-recursive <code>let</code>, as in Henderson&rsquo;s Lispkit, is simply reduced to an equivalent <code>lambda</code> expression, <code>(let (x e) e-body)</code> being <code>(lambda (x) e-body)</code> applied to argument <code>e</code>, and presents no difficulty.) The specificity of recursive block is that each variable is evaluated in an environment that binds all the variables in the <code>let</code> block, so that this <i>augmented</i> environment is a form of fixed point in the operation of binding variables.
</p>
</div>
</div>

<div id="outline-container-orgf3f55ca" class="outline-3">
<h3 id="orgf3f55ca"><span class="section-number-3">3.2</span> FUNX SECD Abstract Machine</h3>
<div class="outline-text-3" id="text-3-2">
<p>
In this section we borrow freely from Henderson&rsquo;s book for the description of the SECD machine,  The SECD machine, invented in its original form by Landin, derives its name from the designation of its four principal components, or registers.
</p>

<dl class="org-dl">
<dt>stack</dt><dd>used to hold values of expressions during computation.</dd>
<dt>environment</dt><dd>used to hold bindings of variables to values during computation.</dd>
<dt>control list</dt><dd>used to hold the abstract machine program being executed.</dd>
<dt>dump</dt><dd>used as a general stack to hold values of other registers, particularly when calling functions</dd>
</dl>

<p>
All registers hold sexps that usually are lists of sexps. The entire state of the SECD machine is given by giving the content of its four registers. The program of a SECD machine is also a sexp, a list of <i>control-sexps</i> usually atomic, which are read sequentially. Each individual control transforms the state of the SECD machine, so that each is an instruction for a machine transition, written as:
</p>

<p>
<code>s e c d -&gt; s' e' c' d'</code>
</p>

<p>
The control list constitutes the program of the abstract machine and tells it how to move from state to state, following the sequence of machine transitions each individual control in the list denotes<sup><a id="fnr.25" class="footref" href="#fn.25">25</a></sup>. (Control lists are also called continuations in this info file.)
</p>

<p>
For instance, and with a bit of heads-on over the next section, let us look at the control list for simple arithmetics:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(mul (<span style="color: #F92672;">quote</span> 2) (<span style="color: #F92672;">quote</span> 3))
</pre>
</div>

<p>
The expected control list for the above <code>funx</code> sexp would be:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(LDC 2 LDC 3 MUL STOP)
</pre>
</div>

<p>
It introduces three controls:
</p>

<dl class="org-dl">
<dt>LDC</dt><dd>Pushes the following constant sexp on the stack.</dd>
<dt>MUL</dt><dd>Pops values from the stack twice, multiplies them and pushes back the result on the stack.</dd>
<dt>STOP</dt><dd>Stops the abstract machine, leaving the state untouched.</dd>
</dl>

<p>
And the natural execution of this program with initially nulled stack, environment and dump registers would look like the following sequence of transitions:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Sequence</th>
<th scope="col" class="org-left">s</th>
<th scope="col" class="org-left">e</th>
<th scope="col" class="org-left">c</th>
<th scope="col" class="org-left">d</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-left">nil</td>
<td class="org-left">nil</td>
<td class="org-left">(LDC 2 LDC 3 MUL STOP)</td>
<td class="org-left">nil</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">(2)</td>
<td class="org-left">nil</td>
<td class="org-left">(LDC 3 MUL STOP)</td>
<td class="org-left">nil</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">(3 2)</td>
<td class="org-left">nil</td>
<td class="org-left">(MUL STOP)</td>
<td class="org-left">nil</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">(6)</td>
<td class="org-left">nil</td>
<td class="org-left">(STOP)</td>
<td class="org-left">nil</td>
</tr>
</tbody>
</table>

<p>
with the result nicely sitting on top of the stack when the machine finally stops.
</p>
</div>

<div id="outline-container-orge021ee4" class="outline-4">
<h4 id="orge021ee4"><span class="section-number-4">3.2.1</span> Operational semantics</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
The operational semantics of the abstract machine is then defined by each control and its associated machine transition. The mnemonics for the controls in the abstract machine are as follows:
</p>


<dl class="org-dl">
<dt>LD</dt><dd>push variable&rsquo;s value on the stack</dd>
</dl>
<dl class="org-dl">
<dt>LDC</dt><dd>push constant on the stack</dd>
</dl>
<dl class="org-dl">
<dt>LDF</dt><dd>push function-plus-environment closure on the stack</dd>
</dl>

<dl class="org-dl">
<dt>ADD</dt><dd>apply arithmetic operator to top two stack values, push result back</dd>
</dl>
<dl class="org-dl">
<dt>SUB</dt><dd>apply arithmetic operator to top two stack values, push result back</dd>
</dl>
<dl class="org-dl">
<dt>MUL</dt><dd>apply arithmetic operator to top two stack values, push result back</dd>
</dl>
<dl class="org-dl">
<dt>DIV</dt><dd>apply arithmetic operator to top two stack values, push result back</dd>
</dl>
<dl class="org-dl">
<dt>REM</dt><dd>apply arithmetic operator to top two stack values, push result back</dd>
</dl>

<dl class="org-dl">
<dt>CAR</dt><dd>replace top of stack by its head</dd>
</dl>
<dl class="org-dl">
<dt>CDR</dt><dd>replace top of stack by its tail</dd>
</dl>
<dl class="org-dl">
<dt>CONS</dt><dd>pop top two stack values, push back <i>cons</i> of values</dd>
</dl>
<dl class="org-dl">
<dt>ATOM</dt><dd>test for atomicity, replace top of stack by boolean <code>*T*</code>, <code>*F*</code></dd>
</dl>
<dl class="org-dl">
<dt>EQ</dt><dd>test for equality of popped top two stack values, push boolean result</dd>
</dl>
<dl class="org-dl">
<dt>LEQ</dt><dd>test for lower-than popped top two stack values, push boolean result</dd>
</dl>
<dl class="org-dl">
<dt>SEL</dt><dd>select control for <code>if</code> sexps, followed by two arguments in the control list: sexp if top of stack is <code>*T*</code>, and sexp if top of stack is <code>*F*</code></dd>
</dl>
<dl class="org-dl">
<dt>JOIN</dt><dd>terminates a sexp in SEL control, and proceeds to the next control after SEL in list</dd>
</dl>

<dl class="org-dl">
<dt>AP</dt><dd>apply function on top of stack, push result back</dd>
</dl>
<dl class="org-dl">
<dt>RTN</dt><dd>terminates a function definition in LDF argument, push the top of the stack as the result of the function application</dd>
</dl>
<dl class="org-dl">
<dt>DUM</dt><dd>opens a recursive <code>let</code> block</dd>
</dl>
<dl class="org-dl">
<dt>RAP</dt><dd>recursive apply, evaluate sexp in a recursive <code>let</code> block</dd>
</dl>

<p>
In order to facilitate the presentation we grouped the controls in several categories:
</p>
</div>

<ol class="org-ol">
<li><a id="org8025fee"></a>ld-group<br />
<div class="outline-text-5" id="text-3-2-1-1">
<p>
The load group of controls usually push a value on the stack.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">s</th>
<th scope="col" class="org-left">e</th>
<th scope="col" class="org-left">c</th>
<th scope="col" class="org-left">d</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">s</td>
<td class="org-left">e</td>
<td class="org-left">(LDC sexp . c)</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">(sexp . s)</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">s</td>
<td class="org-left">e</td>
<td class="org-left">(LD x . c )</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">((<code>locate</code> x e) . s</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">s</td>
<td class="org-left">e</td>
<td class="org-left">(LDF f-sexp . c)</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">((f-sexp e) . s)</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
In the transition table above, <code>locate</code> is a environment utility function which given a variable name and an environment returns the value bound to the variable in the environment, or <code>nil</code> if no such binding is found. Note that <code>sexp</code> denotes any sexp, and <code>f-sexp</code> denotes a function sexp (i.e. a list which head is a list of named arguments, and tail is the control list for the body of the function), so that the <code>LDF</code> control pushes a closure (function + environment) on the stack.
</p>
</div>
</li>

<li><a id="orgcbc72d3"></a>arith-group<br />
<div class="outline-text-5" id="text-3-2-1-2">
<p>
The machine transitions for the arithmetic group all have the same form:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">s</th>
<th scope="col" class="org-left">e</th>
<th scope="col" class="org-left">c</th>
<th scope="col" class="org-left">d</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(a b . s)</td>
<td class="org-left">e</td>
<td class="org-left">(&lt;OP&gt; . c)</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">(&lt;a OP b&gt; . s)</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="org3d3ef89"></a>ops-group<br />
<div class="outline-text-5" id="text-3-2-1-3">
<p>
This group contains the basic operations on values in <code>funx</code>.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">s</th>
<th scope="col" class="org-left">e</th>
<th scope="col" class="org-left">c</th>
<th scope="col" class="org-left">d</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">;; Lists</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">((a . b) s)</td>
<td class="org-left">e</td>
<td class="org-left">(CAR . c)</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">(a . s)</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">((a . b) s)</td>
<td class="org-left">e</td>
<td class="org-left">(CDR . c)</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">(b . s)</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(a b s)</td>
<td class="org-left">e</td>
<td class="org-left">(CONS . c)</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">((a . b) s)</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">;; Tests</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(a s)</td>
<td class="org-left">e</td>
<td class="org-left">(ATOM . c)</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">([*T*,*F*] s)</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(a b s)</td>
<td class="org-left">e</td>
<td class="org-left">(EQ . c)</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">([*T*,*F*] s)</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(a b s)</td>
<td class="org-left">e</td>
<td class="org-left">(LEQ . c)</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">([*T*,*F*] s)</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">;; IF control</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">([*T*,*F*]  s)</td>
<td class="org-left">e</td>
<td class="org-left">(SEL cT cF . c)</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">s</td>
<td class="org-left">e</td>
<td class="org-left">[cT, cF]</td>
<td class="org-left">(c d)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">s</td>
<td class="org-left">e</td>
<td class="org-left">(JOIN)</td>
<td class="org-left">(c d)</td>
</tr>

<tr>
<td class="org-left">s</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Notes: <code>funx</code> provides only simple primitive tests: atomicity, equality (implemented here as LISP&rsquo;s <code>EQUAL</code>) and comparison of numbers. The conditional control is implemented by pushing the continuation on the dump register and entering the appropriate control list branch; the <code>JOIN</code> control always terminates each branch, and reinstalls the continuation from the dump register. (There are other ways to implement the conditional control, of course.)
</p>
</div>
</li>

<li><a id="org1d36129"></a>fun-group<br />
<div class="outline-text-5" id="text-3-2-1-4">
<p>
This group implements the function application and lambda-function definitions.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">s</th>
<th scope="col" class="org-left">e</th>
<th scope="col" class="org-left">c</th>
<th scope="col" class="org-left">d</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">;; Application</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(f-sexp vals s)</td>
<td class="org-left">e</td>
<td class="org-left">(AP c)</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left">((args-f-sexp . vals) e-f-sexp)</td>
<td class="org-left">cl-f-sexp</td>
<td class="org-left">(s e c d)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(ret-val)</td>
<td class="org-left">e&rsquo;</td>
<td class="org-left">(RTN)</td>
<td class="org-left">(s e c d)</td>
</tr>

<tr>
<td class="org-left">(ret-val s)</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">;; <code>let</code> block</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">s</td>
<td class="org-left">e</td>
<td class="org-left">(DUM c)</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">s</td>
<td class="org-left">(OMEGA e)</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(f-sexp vals s)</td>
<td class="org-left">(OMEGA e)</td>
<td class="org-left">(RAP c)</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left"><code>rplaca</code></td>
<td class="org-left">cl-f-sexp</td>
<td class="org-left">(s e c d)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">((args-f-sexp . vals) e-f-sexp)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Notes: the <code>AP</code> control works in association with the <code>LDF</code> which loads a closure on the stack. It pushes the state to the dump register and enters the control list in the closure, within an environment resulting from pushing the association list of function arguments and values from the stack to the environment stored in the closure. The <code>RTN</code> control, which always terminates a control list in a closure, reinstates the machine state from the dump register and pushes the result (top of the stack) of the function application to the recovered stack.
</p>

<dl class="org-dl">
<dt>args-f-sexp</dt><dd>extracts the argument names from the closure sexp</dd>
<dt>vals</dt><dd>popped values from the stack, on for each function argument in order</dd>
<dt>e-f-sexp</dt><dd>extracts the environment from the closure sexp</dd>
<dt>cl-f-sexp</dt><dd>extracts the control list from the closure sexp</dd>
<dt>OMEGA</dt><dd>a literal constant used as placeholder for the <code>car</code> of the environment which is altered by,</dd>
<dt>rplaca</dt><dd>replaces OMEGA in its argument by a pointer the association list of function arguments and values from the stack, and returns a pointer to itself (this implements the recursive nature of the <code>let</code> block)</dd>
</dl>

<p>
The <code>DUM</code> control opens a <code>let</code> recursive block which expects a <code>LDF &lt;closure&gt; RAP</code> to terminate it, where the environment in the closure will be altered in-place by pushing the variable definitions in the <code>let</code> statement.
</p>

<p>
As an example, the factorial function in <code>funx</code> from above:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>The perennial factorial example, example <code>ex1.lsp</code>.</label><pre class="src src-emacs-lisp">(<span style="color: #F92672;">let</span>
    ((fac
      (<span style="color: #F92672;">lambda</span> (n)
        (<span style="color: #F92672;">if</span> (eq n (<span style="color: #F92672;">quote</span> 1)) (<span style="color: #F92672;">quote</span> 1) (mul n (fac (sub (<span style="color: #F92672;">quote</span> 1) n))))))
     )
  (fac (<span style="color: #F92672;">quote</span> 3))
  )
</pre>
</div>


<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>The perennial factorial example compiled, 3! in <code>ex1.fasl</code>.</label><pre class="src src-emacs-lisp" id="orgfb788d8">(DUM 
 LDF ((n) LDC 1 
          LD n 
          EQ 
          SEL (LDC 1 JOIN) 
              (LD n LDC 1 SUB LD fac AP LD n MUL JOIN) 
          RTN) 
 LDF ((fac) LDC 3 LD fac AP RTN) 
 RAP 
 STOP)
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org72e7fc8" class="outline-4">
<h4 id="org72e7fc8"><span class="section-number-4">3.2.2</span> Running the funx SECD Abstract Machine</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
The executive for the SECD Abstract Machine is found in the <code>secd-exec.el</code> file. It is a simple automaton that moves the state of the machine to the next one according to the values of its registers <code>s, e, c,</code> and <code>d</code>. At each step the transition is looked up into the representation of last section&rsquo;s transition tables, and the transformation of state indicated is performed until the special control <code>STOP</code> is found.
</p>

<div class="defun">
<p>
Steps through the control list <i>control</i>, with initial stack, environment and dump as provided and stops at <code>STOP</code> control, returning the state of the stopped machine as the list <code>(s e c d)</code>.
</p>

</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(secd-cycle nil nil '(LDC 2 LDC 3 MUL STOP) nil)
    =&gt; ((6) nil (STOP) nil)
</pre>
</div>
</div>
</div>

<div id="outline-container-org259e100" class="outline-4">
<h4 id="org259e100"><span class="section-number-4">3.2.3</span> A funx strict compiler</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
The strict compiler translates <code>funx</code> sexps to SECD Abstract Machine control lists. It is strict, or eager, in the sense that in function applications, arguments are evaluated first, in left-to-right-order, and pushed on the stack; the function code is pushed on the stack and the application control, <code>AP</code> or <code>RAP</code> is executed. This is also known as <i>call-by-value</i>.
</p>

<p>
Of course, other strategies are possible. For instance, rather than evaluating the arguments first, which might not be used in the body of the function thus wasting precious computing resources, the translation could substitute the evaluation code for the arguments in the body of the function. This is the <i>call-by-name</i> convention rule. (Note that using call-by-name, functions may be defined even for arguments which computation would not terminate in call-by-value evaluation.)
</p>

<p>
Following Henderson&rsquo;s book, the strict compiler implements the following translation of sexps:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"><code>funx</code> sexp</th>
<th scope="col" class="org-left">SECD Control List</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">T v</td>
<td class="org-left">LD v</td>
</tr>

<tr>
<td class="org-left">T (quote s)</td>
<td class="org-left">LDC s</td>
</tr>

<tr>
<td class="org-left">T (add s1 s2)</td>
<td class="org-left">T s2 T s1 ADD</td>
</tr>

<tr>
<td class="org-left">T (leq s1 s2)</td>
<td class="org-left">T s2 T s1 LEQ</td>
</tr>

<tr>
<td class="org-left">T (atom s)</td>
<td class="org-left">T s ATOM</td>
</tr>

<tr>
<td class="org-left">T (car s)</td>
<td class="org-left">T s CAR</td>
</tr>

<tr>
<td class="org-left">T (cdr s)</td>
<td class="org-left">T s CDR</td>
</tr>

<tr>
<td class="org-left">T (cons s1 s2)</td>
<td class="org-left">T s2 T s1 CONS</td>
</tr>

<tr>
<td class="org-left">T (if s1 s2 s3)</td>
<td class="org-left">T s1 SEL (T s2 JOIN) (T s3 JOIN)</td>
</tr>

<tr>
<td class="org-left">T (lambda (v1 &#x2026; vn) s)</td>
<td class="org-left">LDF ((v1 &#x2026; vn) T s RTN)</td>
</tr>

<tr>
<td class="org-left">T (let ((v1 s1) &#x2026; (vn sn)) s)</td>
<td class="org-left">DUM T sn &#x2026; T s1 LDF ((v1 &#x2026; vn) T s RTN) RAP</td>
</tr>

<tr>
<td class="org-left">T (s s1 &#x2026; sn)</td>
<td class="org-left">T sn &#x2026; T s1 T s AP</td>
</tr>
</tbody>
</table>


<p>
where <code>v</code>, <code>s1 ... sn</code> are variable names, the value of which will be found in the environment register of the SECD machine; and <code>s</code>, <code>s1 ... sn</code> are well-formed <code>funxp</code> sexps. (The other arithmetic sexps are translated like <code>add</code>.)
</p>

<p>
Note that there are minor differences with the translation in Henderson&rsquo;s book, related to the implementation of the environment and to the single <code>let</code> sexp, which does note distinguishes between recursive and non-recursive blocks.
</p>

<p>
In Emacs-Lisp the strict compiler is invoked by:
</p>

<p>
-- Function <b>secd-comp--comp</b> expression names controls
</p>
<div class="defun">
<p>
<i>expression</i> is the <code>funx</code> sexp to translate; <i>names</i> is a register of variable names defined in <i>expression</i>: this is unused in the strict compiler, but will be used in the NXP lazy variant of the compiler; <i>controls</i> is the recursively built list of controls.
</p>

</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(secd-comp--comp '(mul (<span style="color: #F92672;">quote</span> 2) (<span style="color: #F92672;">quote</span> 3)) nil '(STOP))
    =&gt; (LD 3 LD 2 MUL STOP)
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="orgf1a6829"></a>Another perennial example, compiling the compiler<br />
<div class="outline-text-5" id="text-3-2-3-1">
<p>
As a footnote to this section, we could not skip the &ldquo;compile the compiler&rdquo; exercise! The simple <code>funx</code> functional language is expressive enough to implement the translation to SECD Abstract Machine control lists. The previous example is found in the <code>examples/comp3.lsp</code> file, which once compiled with the Emacs-Lisp <code>secd-comp--comp</code> function above produces the following control list, with the <code>funxp</code> sexp <code>'(mul (quote 2) (quote 3))</code> to be compiled loaded (as a constant, <code>LDC</code>) on the stack.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(DUM LDF ((elist) LD nil LD elist EQ SEL (LD nil JOIN) (LD elist
CDR LD secd-comp--vars AP LD elist CAR CAR CONS JOIN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">RTN)</span>
LDF ((elist n c) LD nil LD elist EQ SEL (LD c JOIN) (LD c LD n LD
elist CAR CDR CAR LD secd-comp--comp AP LD n LD elist CDR LD
secd-comp--list AP JOIN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">RTN) LDF ((e n c) LD e ATOM SEL (LD c LD</span>
e CONS LDC LD CONS JOIN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">(LDC car LD e CAR EQ SEL (LD c LDC CAR</span>
CONS LD n LD e CDR CAR LD secd-comp--comp AP JOIN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">(LDC cdr LD e</span>
CAR EQ SEL (LD c LDC CDR CONS LD n LD e CDR CAR LD
secd-comp--comp AP JOIN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">(LDC atom LD e CAR EQ SEL (LD c LDC ATOM</span>
CONS LD n LD e CDR CAR LD secd-comp--comp AP JOIN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">(LDC quote LD</span>
e CAR EQ SEL (LD c LD e CDR CAR CONS LDC LDC CONS JOIN) (LDC cons
LD e CAR EQ SEL (LD c LDC CONS CONS LD n LD e CDR CAR LD
secd-comp--comp AP LD n LD e CDR CDR CAR LD secd-comp--comp AP
JOIN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">(LDC eq LD e CAR EQ SEL (LD c LDC EQ CONS LD n LD e CDR CAR</span>
LD secd-comp--comp AP LD n LD e CDR CDR CAR LD secd-comp--comp AP
JOIN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">(LDC leq LD e CAR EQ SEL (LD c LDC LEQ CONS LD n LD e CDR</span>
CAR LD secd-comp--comp AP LD n LD e CDR CDR CAR LD
secd-comp--comp AP JOIN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">(LDC add LD e CAR EQ SEL (LD c LDC ADD</span>
CONS LD n LD e CDR CAR LD secd-comp--comp AP LD n LD e CDR CDR
CAR LD secd-comp--comp AP JOIN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">(LDC sub LD e CAR EQ SEL (LD c</span>
LDC SUB CONS LD n LD e CDR CAR LD secd-comp--comp AP LD n LD e
CDR CDR CAR LD secd-comp--comp AP JOIN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">(LDC mul LD e CAR EQ</span>
SEL (LD c LDC MUL CONS LD n LD e CDR CAR LD secd-comp--comp AP LD
n LD e CDR CDR CAR LD secd-comp--comp AP JOIN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">(LDC div LD e CAR</span>
EQ SEL (LD c LDC DIV CONS LD n LD e CDR CAR LD secd-comp--comp AP
LD n LD e CDR CDR CAR LD secd-comp--comp AP JOIN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">(LDC rem LD e</span>
CAR EQ SEL (LD c LDC REM CONS LD n LD e CDR CAR LD
secd-comp--comp AP LD n LD e CDR CDR CAR LD secd-comp--comp AP
JOIN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">(LDC if LD e CAR EQ SEL (LDC (JOIN) LD n LD e CDR CDR CDR</span>
CAR LD secd-comp--comp AP LDC (JOIN) LD n LD e CDR CDR CAR LD
secd-comp--comp AP LDF ((cont-t cont-f) LD c LD cont-f CONS LD
cont-t CONS LDC SEL CONS LD n LD e CDR CAR LD secd-comp--comp AP
RTN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">AP JOIN) (LDC lambda LD e CAR EQ SEL (LD c LDC (RTN) LD n LD</span>
e CDR CDR CAR LD secd-comp--comp AP LD e CDR CAR CONS CONS LDC
LDF CONS JOIN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">(LDC let LD e CAR EQ SEL (LD c LDC RAP CONS</span>
LDC (RTN) LD n LD e CDR CDR CAR LD secd-comp--comp AP LD e CDR
CAR LD secd-comp--vars AP CONS CONS LDC LDF CONS LD n LD e CDR
CAR LD secd-comp--list AP LDC DUM CONS JOIN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">(LD c LDC AP CONS LD</span>
n LD e CAR LD secd-comp--comp AP LD n LD e CDR LD secd-comp--args
AP JOIN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">JOIN) JOIN) JOIN) JOIN) JOIN) JOIN) JOIN) JOIN) JOIN)</span>
JOIN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">JOIN) JOIN) JOIN) JOIN) JOIN) RTN) LDF ((secd-comp--comp</span>
secd-comp--list secd-comp--vars) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">LD nil LD nil LDC (mul '2 '3) LD</span>
secd-comp--comp AP RTN) <span style="color: #FD971F; font-weight: bold; font-style: italic; text-decoration: underline;">RAP STOP)</span>
</pre>
</div>

<p>
Running the SECD machine on this control list then produces the expected:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">=&gt; (LD 3 LD 2 MUL STOP)
</pre>
</div>

<p>
which run again through the SECD machine will finally output <code>6</code>!
</p>
</div>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orge12a3fb" class="outline-2">
<h2 id="orge12a3fb"><span class="section-number-2">4</span> Extending for NXP-style inferencing, funxp</h2>
<div class="outline-text-2" id="text-4">
<p>
In order to build the NXP Architecture on top of the <code>funx</code> functional programming language, we will first extend the features of the language with Henderson&rsquo;s <i>delay-force</i> mechanism for delayed evaluations of sexps.
</p>

<p>
While delayed evaluations expose some of the parallel nature of functional programming languages, where sexps are viewed as separate threads in a network of communicating processes, we will not explore this further in the current implementations<sup><a id="fnr.26" class="footref" href="#fn.26">26</a></sup>.
</p>

<p>
Similarly, while delayed evaluations make it possible to write functional programs which process infinite structures, e.g. infinite lists, this is a feature we will not explore in the following sections.
</p>

<p>
The NXP Architecture uses delayed evaluations for all evaluations of facts, conditions, rules and hypotheses defined in NXP knowledge bases. The proper order of execution of these delayed evaluations, based on one or more heuristics, constitutes the control structure of an interactive session, also called the <i>agenda</i>. In the current implementation, the agenda is simply represented by the global control list of the underlying SECD Machine.
</p>

<p>
In order to emphasize delayed evaluations, we call the functional language <code>funx</code> augmented with delayed evaluations: <code>funxp</code>.
</p>
</div>

<div id="outline-container-org7770835" class="outline-3">
<h3 id="org7770835"><span class="section-number-3">4.1</span> Promises are delayed evaluations</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Delayed evaluations lead to lazy evaluation of sexps, compared to typical call-by-value eager evaluations  It is usually introduced explicitly in augmenting the well-formed expression with explicit delaying and forcing evaluation, so that <code>(delay e)</code> and <code>(force e)</code> are well-formed sexps when <code>e</code> is a well-formed sexp, and <code>(force (delay e))</code> has the same value as <code>e</code>.
</p>

<p>
The value of <code>(delay e)</code> is a closure-like structure, we call a <i>promise</i>. It incorporates a representation of the expression&#x2013;its compiled control list in the compiler output&#x2013;and the environment in which to be evaluated.
</p>

<p>
Note that one interpretation of the delay/force could readily be implemented in <code>funx</code> without extension. Making an expression <code>e</code> into a function with no parameter <code>(lambda () e)</code> has indeed the effect of postponing the evaluation until it is actually called with no argument, <code>((lambda () e))</code>. This interpretation however would cause the function to be evaluated twice if called twice as opposed to once only, as in <code>(let ((val (lambda () e))) (cons (val) (val)))</code>.
</p>

<p>
An alternative interpretation would be that the value of the delayed function is represented by a closure containing <code>e</code> which, when forced, is replaced by the value resulting from the evaluation of <code>e</code>. The next forcing would return this previous evaluation result rather than trigger a new evaluation<sup><a id="fnr.27" class="footref" href="#fn.27">27</a></sup>. The <code>funx</code> control set is thus expanded to make the latter interpretation precise:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"><code>funxp</code> feature</th>
<th scope="col" class="org-left">Control lists</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">T (delay s)</td>
<td class="org-left">LDE T s UPD</td>
</tr>

<tr>
<td class="org-left">T (force s)</td>
<td class="org-left">T s AP0</td>
</tr>

<tr>
<td class="org-left">T NXP-s</td>
<td class="org-left">LDP NXP-s</td>
</tr>
</tbody>
</table>

<p>
where <code>NXP-s</code> designates an NXP special sexp (fact, condition, rule, action or hypothesis), and introducing new controls:
</p>

<dl class="org-dl">
<dt>LDE</dt><dd>load the following promise on stack</dd>
</dl>
<dl class="org-dl">
<dt>LDP</dt><dd>load the named promise from the environment</dd>
</dl>
<dl class="org-dl">
<dt>AP0</dt><dd>evaluate the promise on top of the stack, stores the result of the evaluation in the promise, or if already evaluated, use that value</dd>
</dl>
<dl class="org-dl">
<dt>UPD</dt><dd>terminates a promise definition (in LDE argument)</dd>
</dl>
</div>

<div id="outline-container-org1a5cb7b" class="outline-4">
<h4 id="org1a5cb7b"><span class="section-number-4">4.1.1</span> lazy-group</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
Transitions for the new controls are as follows: 
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">s</th>
<th scope="col" class="org-left">e</th>
<th scope="col" class="org-left">c</th>
<th scope="col" class="org-left">d</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">s</td>
<td class="org-left">e</td>
<td class="org-left">(LDE c . c)</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">((PROMISE c e) . s)</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">s</td>
<td class="org-left">e</td>
<td class="org-left">(LDP x . c )</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">((<code>locate</code> x e) . s</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">((v e) . s)</td>
<td class="org-left">e</td>
<td class="org-left">(AP0 . c)</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">(v . s)</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">((PROMISE c e) . s)</td>
<td class="org-left">e&rsquo;</td>
<td class="org-left">(AP0 . c&rsquo;)</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">(((PROMISE c e) . s) e&rsquo; c&rsquo; d)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(v)</td>
<td class="org-left">e</td>
<td class="org-left">(UPD)</td>
<td class="org-left">(((PROMISE c e) . s) e&rsquo; c&rsquo; d)</td>
</tr>

<tr>
<td class="org-left">(v . s)</td>
<td class="org-left">e&rsquo;</td>
<td class="org-left">c&rsquo;</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">and (PROMISE c e) =&gt; (v e)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Note that the promise is distinct from a standard closure, having the reserved keyword <code>PROMISE</code> when delayed. The <code>AP0</code> control first checks for this keyword and evaluates the closure as usual if delayed, or returns the result of the previous evaluation if present. (Hence the two lines in the previous table.)
</p>

<p>
The <code>UPD</code> control has an additional side-effect which is to update the promise with the result of the evaluation for further reference. Here we rely on the notion than only one update is necessary to alter the promise in place. (Implementations should probably never copy promises and systematically use pointers to premises to alleviate the consistency checks.) Updates affect all the subsequent accesses to the promise.
</p>
</div>
</div>

<div id="outline-container-org881464e" class="outline-4">
<h4 id="org881464e"><span class="section-number-4">4.1.2</span> Lazy evaluation</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
With this feature added in <code>funxp</code> the precise definition of a lazy evaluator (or compiler for that matter) is obtained by considering a strict evaluator (or compiler) and making the following changes throughout the entire program:
</p>

<ul class="org-ul">
<li>delay all arguments to user-defined function sexps.</li>
<li>delay both arguments to <code>cons</code>,</li>
<li>delay all definitions in <code>let</code> recursive blocks.</li>
<li>repeatedly force all arguments to primitives other than <code>cons</code> (e.g. <code>car</code> &#x2026;)</li>
<li>repeatedly force the test in <code>if</code> sexps.</li>
<li>repeatedly force the function in applications.</li>
</ul>

<p>
These can be written as simple program <i>transformations</i> performed just before evaluation or compilation of <code>funxp</code> sexps.
</p>
</div>
</div>
</div>

<div id="outline-container-org363d395" class="outline-3">
<h3 id="org363d395"><span class="section-number-3">4.2</span> Rules and Knowledge Bases</h3>
<div class="outline-text-3" id="text-4-2">
<p>
We are now ready to introduce the NXP Architecture specific functional expressions to complete the specification of <code>funxp</code>. All the new well-formed sexps are related to the core novel issues brought forward in rule systems: the issue of <i>interactivity</i> with the user, and more generally with external sources of data required by the inference process on the one hand, and the issue of the control structure(s) in problem-solving&#x2013;a notoriously complex question <sup><a id="fnr.28" class="footref" href="#fn.28">28</a></sup>.
</p>

<p>
This section focuses on the new constructs introduced by the NXP Architecture rule system. It also provides some motivations for their introduction and intended use in problem representation and problem-solving performance. The next section explains the <code>funxp</code> compiler which translate these constructs into executable control lists on the SECD Abstract Machine.
</p>

<p>
The general rule sexp in <code>funxp</code> is as follows:
</p>

<p>
-- Function <b>rule</b> hypo lhs [rhs context]
</p>
<div class="defun">
<p>
A rule sexp where <i>hypo</i> is an hypothesis, or goal; <i>lhs</i>, for <i>left-hand side</i> (LHS) is a list of conditions; optional <i>rhs</i>, for <i>right-hand side</i> (RHS) is a list of actions; and optional <i>context</i> is a list of properties.
</p>

</div>

<p>
where:
</p>

<dl class="org-dl">
<dt>hypothesis</dt><dd>also called a goal, or a hypo, is a symbol which conventionally evaluates to true (<code>*T*</code>) when all the conditions in the left-hand side are matched and to false (<code>*F*</code>) if any one (or more) of the conditions in the left-hand side does not match.</dd>
<dt>lhs</dt><dd>a list of conditions.</dd>
<dt>condition</dt><dd>a sexp which is a <code>funxp</code> expression that evaluates to true (<code>*T*</code>) or false (<code>*F*</code>) exclusively.</dd>
<dt>rhs</dt><dd>a list of actions.</dd>
<dt>action</dt><dd>a sexp exclusively of the form <code>(set s sexp)</code> where <code>s</code> is a symbol and <code>sexp</code> a well-formed <code>funxp</code> expression that calculates the value assigned to <code>s</code>.</dd>
<dt>context</dt><dd>is a property written as <code>:context sexp</code> where <code>sexp</code> a well-formed <code>funxp</code> expression, usually a list of symbols.</dd>
</dl>

<p>
The motivation for this compact form is to express that a rule says that when all its conditions in the LHS are true (matched by values of data in working memory), the rule <i>fires</i>, becomes true,  and the hypothesis becomes true.
</p>

<p>
A knowledge base is a list of rule sexps.
</p>

<p>
Note that within a knowledge base, a given hypothesis may appear in several rules. By convention, during evaluation if all of these rules evaluate to false (and consequently none is fired) the hypothesis becomes false.
</p>

<p>
Hence a hypo turns out true if at least one of its rules in the knowledge base is true (and fired); it turns out false if all of its rules in the knowledge base are evaluated to false (hence none fired); and remains <i>unknown</i> if only some of its rules have been evaluated, and to false.
</p>
</div>

<div id="outline-container-org89274ab" class="outline-4">
<h4 id="org89274ab"><span class="section-number-4">4.2.1</span> Interactive user interfaces</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
In rule systems, see  <a href="#org5c1472b">1.2</a>, rules are matched against data which resides in <i>working memory</i>. In the current implementation we opt for mapping the working memory into the environment register of the SECD Abstract Machine, and designates each datum simply by a symbol in <code>funxp</code>.
</p>

<p>
Values for these data may be computed, evaluated, or deduced by the rule system as the problem-solving progresses. Values might also be required, or collected from data sources external to the rule system itself, including from the user. The I/O channel between the rule system and its peripheral systems involves, in its generality, issues of sync/async control in communications. The current implementation simplifies the latter by considering only one data source, the user, and consequently one extension to the set of well-formed <code>funxp</code> sexps, the <i>question</i>. We will see that the management of the question is quite generic and may be easily adapted to other data source, e.g. relational databases or Web Services queries.
</p>

<p>
The newly introduced well-formed sexp is: <code>(question s)</code> where <code>s</code> is a symbol, which naturally translates to &ldquo;What is the value of s?&rdquo; (Later, we show how to customize text prompts for the text-based user interface in Emacs.)
</p>

<p>
This new sexp also introduces the new convention that evaluation stops at a question, waiting for an answer from the user to resume the evaluation at some later point in time. This makes the evaluation by the rule system interactive, as several questions might be asked in the process of running the system. The full cycle of interaction with the rule system, until it terminates, is called a <i>session</i>. Sessions are reminiscent of the famous <i>protocols</i> studied by Newell and Simon as a method for eliciting knowledge from human experts.
</p>

<p>
In the current implementation, the user being the single data source, any symbol, the required value of which is not present in working memory nor can be computed or evaluated by the rule system, is deemed collectible from external data sources, i.e. the user, and a corresponding question is output and evaluation stops.
</p>

<p>
Note that since more than one data collection for different rules could be going on simultaneously from an evaluation perspective, there could logically be several pending questions at any given output. In the current implementation, as mentioned early, we did not address issues of parallelism which could gracefully handle the synchronization of inference threads within the framework of the <code>funxp</code> delayed evaluations. Instead we will introduce NXP-specific control structures to captures the proper sequencing of interaction with the user&#x2013;an important criterion of usability of expert systems, 
</p>

<p>
Note also that this mechanism may easily be extended to other data sources by introducing similar well-formed expressions, possibly arranged in a stack where failure to find the value of the required symbol in the top of the stack data source cause popping it out and trying the next one, addressing the question to the user at a last resort.
</p>
</div>
</div>

<div id="outline-container-org6da13b9" class="outline-4">
<h4 id="org6da13b9"><span class="section-number-4">4.2.2</span> Goal-driven evaluation</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
In goal-driven evaluation, also known as <i>backward chaining</i>, the process starts from an unevaluated hypothesis and collects all its rules in the knowledge base in no particular order. Should one the rule already be evaluated to <code>*T*</code>&#x2013;remember that rules are, like hypotheses, promises and may have been evaluated prior to the current focus&#x2013;the hypothesis is evaluated to <code>*T*</code> without further work. If not, the collected rules are evaluated in sequence.
</p>

<p>
Note that, rules being mapped to promises, if a rule in this sequence has been evaluated prior to the current focus (and necessarily to <code>*F*</code>), it is not re-evaluated, in line with the delay-force mechanism in <code>funxp</code>.
</p>

<p>
The sequential evaluation stops at the first <code>*T*</code> rule value, setting the hypothesis to <code>*T*</code>. When all the rules in the sequence end up evaluated to <code>*F*</code>, the hypothesis is set accordingly to <code>*F*</code>.
</p>

<p>
This sequential hypothesis evaluation is a logical <code>OR</code> of the values of the rules in the knowledge base, which stops at the first logical true value encountered.
</p>
</div>

<ol class="org-ol">
<li><a id="org9921337"></a>Evaluating and firing rules<br />
<div class="outline-text-5" id="text-4-2-2-1">
<p>
In turn, rule evaluation is performed by a sequential evaluation of the conditions in its LHS, following a logical <code>AND</code>. It stops at the first <code>*F*</code> value for a condition and sets the rule value to <code>*F*</code>; when all the conditions evaluate to <code>*T*</code>, the rule value is set to <code>*T*</code>.
</p>

<p>
When a rule is evaluated to <code>*T*</code> during the sequential process its RHS is immediately executed before proceeding to the next rule in sequence. The rule is said to be <i>fired</i>.
</p>

<p>
The list of actions in the RHS is evaluated in sequence. In the current implementation only one type of action is present: assignment of a value to a data.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(set v s)
</pre>
</div>

<p>
where <code>v</code> is a variable name, and <code>s</code> a well-formed <code>funxp</code> sexp to compute the value assigned to <code>v</code>. The assignment may trigger forward-chaining consequences, e.g. posting conditions in other rules on the agenda for later evaluations.
</p>

<p>
Note that evaluation of a RHS sexp and an action sexp individually is always <code>nil</code>. It is ignored by the computation thread.
</p>
</div>
</li>

<li><a id="orgcc41ee2"></a>Evaluating conditions on subgoals<br />
<div class="outline-text-5" id="text-4-2-2-2">
<p>
Conditions are general <code>funxp</code> boolean sexps. In addition, <code>funxp</code> offers two boolean forms for conditions:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(H)
(not H)
<span style="color: #75715E;">;; </span><span style="color: #75715E;">`</span><span style="color: #AE81FF;">not</span><span style="color: #75715E;">' also applies to boolean sexps</span>
(not s)
</pre>
</div>

<p>
where <code>H</code> is another hypothesis (and <code>s</code> any other boolean sexp).
</p>

<p>
When the first two forms are encountered in condition evaluation, the current focus is pushed and the hypothesis <code>H</code> is evaluated. (This is similar to a procedure call in imperative programming languages, or an application in <code>funxp</code> as <code>H</code> is a promise.) In the AI established jargon this is the <i>chaining</i>, here in backward mode as it goes from goal to subgoal.
</p>

<p>
Note that with this convention for chaining from conditions to hypothesis, goals are considered as data, hence also reside in working memory during a session.
</p>
</div>
</li>

<li><a id="orgc0da650"></a>Evaluating conditions on data<br />
<div class="outline-text-5" id="text-4-2-2-3">
<p>
In contrast, when evaluating conditions any required data which is not an hypothesis is asked interactively from the user by default in an interactive session.
</p>

<p>
If a variable <code>v</code> is required, for evaluating a condition, which is not an hypothesis but for which there are some rules in the knowledge base that may set its value in their RHS, a heuristics option in the NXP Architecture exists to trigger backward chaining from <code>v</code> through the RHS of these rules (rather than asking the user in that instance).
</p>

<p>
-- Variable <b>secd--kb-option-backward-chaining-rhs</b>
</p>
<div class="defvar">
<p>
When switched to true, search for and evaluate rules with RHS setting data required in condition evaluation before asking the user. Set to <code>nil</code> by default.
</p>

</div>
</div>
</li>

<li><a id="org1c9c808"></a>Suggesting hypotheses in interactive sessions<br />
<div class="outline-text-5" id="text-4-2-2-4">
<p>
During interactive sessions, hypotheses can be added for later evaluation by posting them to the agenda (also known as <i>suggesting</i> in the NXP Architecture).
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-org91fc27d" class="outline-4">
<h4 id="org91fc27d"><span class="section-number-4">4.2.3</span> Event-driven evaluation</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
In event-driven, or data-driven evaluation, data values are stored in working memory, either from a rule RHS action, from an external data source or a calling external process, of by the user assigning values to some of the data (also known as <i>volunteering</i> information in the NXP Architecture).
</p>
</div>

<ol class="org-ol">
<li><a id="org200c72d"></a>Forward Chaining<br />
<div class="outline-text-5" id="text-4-2-3-1">
<p>
In the <i>forward-chaining</i> process this value-change events trigger evaluation, or reevaluation of LHS conditions of rules requiring the changed variable. Changing the value of a variable, once an interactive session is terminated, to cause reevaluation of goals is also known as <i>what-if</i> queries in the NXP Architecture.
</p>

<p>
(Re)evaluated conditions, in turn, cause (re)evaluation of rules, still with the <code>AND</code> logical connective described above. (Re)evaluated, may then fire, and in turn cause (re)evaluation of hypotheses. If the hypothesis is itself required in a LHS condition, the forward-chaining proceeds with the new focus of attention. Forward-chaining then proceeds generally from data to subgoals, to goals, in a chain of logical deductions.
</p>
</div>
</li>

<li><a id="orgcf49758"></a>Gating<br />
<div class="outline-text-5" id="text-4-2-3-2">
<p>
The NXP Architecture provides a heuristics option to control the forward-chaining deductive step from rule to hypothesis. The rationale for the control is to focus the problem-solving process on confirmed hypotheses or subgoals only, rather than expanding its focus to rules not immediately confirmed by the data at hand. This heuristics is called <i>gating</i> in the NXP Architecture. It applies to forward-chaining and restricts the deductive step from rule to hypothesis to those <code>*T*</code>-valued rules only.
</p>

<p>
<b>secd--kb-option-forward-chaining-gate</b>
</p>
<div class="defvar">
<p>
When true, the deductive step or forward chaining from a rule to its hypothesis is taken only if the rule is found <code>*T*</code> (gating on). When false, the deductive step is always taken whatever the value of the rule (gating off). The default is gating on.
</p>

</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org9cd7a5e" class="outline-4">
<h4 id="org9cd7a5e"><span class="section-number-4">4.2.4</span> Heuristics design space</h4>
<div class="outline-text-4" id="text-4-2-4">
<p>
Backward- and forward-chaining by no means exhaust the possibilities and nuances of control in problem-solving. It is even debatable that computing is all there is to thinking <sup><a id="fnr.5.100" class="footref" href="#fn.5">5</a></sup>, both from the standpoint of the philosophy of mind and from the standpoint of computer science.
</p>

<p>
Rules may be put to many uses in representing the process of problem-solving, <a href="#org4069604">1.2.2</a>, and together with the various chaining and options already mentioned help explore a large portion of the heuristics design space. In pioneering early AIM systems, other representation schemes were also tested, most notably, <i>association</i> and <i>weighted association</i> (also known as <i>certainty factors</i>) relations between data and/or goals, 
</p>

<p>
The <i>hypothesis generation</i> phase is a well-identified and delimited step in the problem-solving task at large<sup><a id="fnr.29" class="footref" href="#fn.29">29</a></sup>. While rules can be used for hypothesis generation, particularly in forward-chaining mode, AI research studied many alternative mechanisms very early on. (Dr Paycha&rsquo;s address to the 1956 First International Congress of Cybernetics already explained medical hypothesis generation in medical consultation by associational links from signs, to syndromes, to diseases, for instance, ) The early NCLOSE system had a separate initial step of hypothesis generation before switching to a &ldquo;deductive&rdquo; mode to logically prove or disprove candidate hypotheses, 
</p>



<div class="figure">
<p><img src="./EVOCATION.jpg" alt="EVOCATION.jpg" />
</p>
<p><span class="figure-number">Figure 8: </span>Schematic diagram of a system for ill-structured problems. It shows the alternation between a problem solver working on a well-structured problem, and a recognition system continually modifying the problem space. (From Simon, 1973)</p>
</div>


<p>
Association links, when used as evoking or noticing, help guide the problem-solving process when confronting <i>ill-structured</i> problems, an analysis brought forward by Herbert Simon. The NXP Architecture provides a generic implementation with the notion of context which can be customized to serve specific heuristics.
</p>

<p>
In order to extend the reach of the NXP Architecture in the heuristics design space, the rule model explicitly supports a form of associational linking, called <i>context</i>, or context links or evocation links. Each rule sexp may be decorated by an optional <code>:context</code> property which is a list of symbols, as in this example:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(rule OBSTRUCTIVE-AIRWAY-DISEASE
    ((leq SLOPE-F50-FVC 32)
     (leq 22 SLOPE-F50-FVC))
    <span style="color: #F92672;">:context</span> '(EMPHYSEMA ASTHMA BRONCHITIS))
</pre>
</div>

<p>
where the main hypothesis <code>OBSTRUCTIVE-AIRWAY-DISEASE</code> may be evocative of one of the following <code>EMPHYSEMA, ASTHMA,</code> or <code>BRONCHITIS</code> without necessarily, at this stage of the problem-solving process, a logical or deductive step being involved.
</p>

<p>
The context links are collected for each hypothesis in the knowledge base by merging, without duplicates, the lists of context symbols found in each rule. A simple graph is then constituted by considering two hypotheses <i>adjacent</i> if they share one or more symbols in their respective contexts. Given hypothesis <code>H</code> we called <i>evoked hypotheses</i> all the hypotheses in this graph that can be reached by following edges, starting from <code>H</code>.
</p>

<p>
When the evaluation of a hypothesis terminates, all the evoked hypotheses are posted to the end of the agenda for later evaluation, once the backward-/forward-chaining processes reach quiescence. Using context links, the focus of attention of the problem-solving task can switch from one area of the problem-space to another, even when there appears to be no formal logical step represented by rules between both. This control of the focus of attention may find several task-dependent uses: differential diagnosis exploration, inductive links, taxonomic links, frame-slot constructs in frame-based knowledge representations, and so forth.
</p>

<p>
Evocation is controlled by a heuristics option:
</p>

<p>
-- Variable <b>secd--kb-option-context</b>
</p>
<div class="defvar">
<p>
When switched to true, triggers evocation from each hypothesis just evaluated. Set to <code>nil</code> by default.
</p>

</div>

<p>
Association can be customized by defining custom context elements. The default heuristics is a context defined as a list of symbols, with equality of symbols used to determined the adjacency relation between hypotheses. This can be changed by defining the heuristics option: 
</p>

<p>
-- Variable <b>secd--kb-option-context-compare</b>
</p>
<div class="defvar">
<p>
When non <code>nil</code>, defines a comparison function to be used when building the adjacency graph of hypotheses from context links. Default value is nil: assumes context lists are lists of symbols and use <code>EQUAL</code> for comparison.
</p>

</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org91edd7e" class="outline-2">
<h2 id="org91edd7e"><span class="section-number-2">5</span> Compiling funxp</h2>
<div class="outline-text-2" id="text-5">
<blockquote>
<p>
What seemed to be missing was the desire to compile.
</p>

<p>
&#x2014; Don De Lillo, <i>The Players</i>
</p>
</blockquote>

<p>
We chose to implement the knowledge base compiler to directly output control lists for a SECD Machine embedded within a NXP Executive which runs the machine according to user commands. An alternative would be to extend the simple variant of LISP with knowledge base related well-formed sexps and use the lazy compiler. Instead, we add a set of well-defined NXP-specific controls to the SECD Machine, and their transitions, to directly capture the rule sexps into controls lists, and rely on an external program, the NXP Executive, to implement the heuristics mentioned in the previous section.
</p>

<p>
Implementing the NXP Architecture from the functional perspective provided by <code>funxp</code> then requires:
</p>
<ul class="org-ul">
<li>extending the SECD repertoire of control operators to accommodate hypotheses, rules, conditions, actions, and variables; as well as I/O to the user and computing environment (here Emacs);</li>
<li>embedding the SECD automaton into a larger executive that orchestrates the basic processes of backward-chaining, forward-chaining and evocation;</li>
<li>embedding the <code>funx</code> (eager) compiler into a knowledge-base compiler that produces a complete state for the augmented SECD Abstract Machine to process.</li>
</ul>

<p>
In the current implementation, the embedding of the SECD executive and the augmented executive itself are both written in Emacs-Lisp, like the implementation of the SECD Abstract Machine. For now, it remains an interesting avenue of research to port the machine and the NXP executive to other programming languages and environments, including <code>funx</code> itself.
</p>

<p>
The same remark applies to the knowledge base compiler, implemented in Emacs-Lisp in the current implementation. The section on compiling the compiler shows that it might be interesting to port the NXP knowledge base compiler to <code>funx</code> with some extra work. This &ldquo;native&rdquo; compiler could then leverage any of the above SECD + NXP Executive program.
</p>

<p>
To introduce a formal note, we plan to implement the following:
</p>

<p>
-- Function <b>secd-comp--kb-knowcess</b> env goals [s var val]
</p>
<div class="defun">
<p>
This runs the NXP SECD Machine on the state (implicitly) provided as arguments.
</p>

<p>
<i>env</i> is the NXP environment produced by the knowledge base compiler.
</p>

<p>
<i>goals</i> is a list of initial hypotheses to evaluate. This will be JIT compiled and added to the initially empty control list. These hypotheses were suggested before running the session.
</p>

<p>
Optional <i>s</i> is an initial stack (usually left at <code>nil</code>).
</p>

<p>
Optional <i>var</i> and <i>val</i> are lists of variables and values, known initially before running the session. They may have been volunteered before running the session, for instance.
</p>

</div>

<p>
-- Function <b>secd-comp--kb2env</b> kb
</p>
<div class="defun">
<p>
Compiles a knowlege base, i.e. a list of <code>rule</code> sexps into an environment for the augmented SECD Abstract Machine. This environment is passed as a first argument to the <i>knowcess</i> command.
</p>

</div>

<p>
In a diagram:
</p>
<pre class="example">

                                                  S                        S  



                         +------------+                                       
                         |            |                                       
Knowledge Base ----------|  COMPILER  | --------&gt; E                        E  
                         |            |                                       
                         +------------+                 +--------------+      
                                                        |  NXP + SECD  |      
                                                        |    MACHINE   |      
                                                        +--------------+      
Initial                                                                       
 Suggest       ---------------------------------&gt; C                        C  
 Volunteer                                                                    




                                                  D                        D  


                                               Initial                   Final
                                                State                    State
</pre>
</div>

<div id="outline-container-org35410b7" class="outline-3">
<h3 id="org35410b7"><span class="section-number-3">5.1</span> Mapping NXP to SECD</h3>
<div class="outline-text-3" id="text-5-1">
<p>
In the current implementation, the first design choice is to map all the NXP-level entities defined above (hypothesis, rule, condition and action, variable) to promises in the functional programming language <code>funxp</code>. The rationale is that each individual component of rules and knowledge bases can be understood as a functional sexp which evaluation is delayed until needed by the problem-solving process.
</p>

<p>
This design choice has several consequences:
</p>
<ul class="org-ul">
<li>The NXP knowledge base compiler produces control lists for every individual entity found in the rule sexps.</li>
<li>Since the promises are evaluated on a call-by-need basis, and the initial focus of attention is provided by the user (through one or several suggest/volunteer commands before running an interactive session), the promises are to be stored in the environment until called by the evaluation process. The output of the knowledge base compiler is therefore an environment ready to be consumed by the NXP SECD Machine.</li>
<li>The starting control list of the NXP SECD Machine will consist of the calls required to evaluate the suggested hypotheses in the environment produced by the compiler, and augmented by the optional volunteer initial commands.</li>
<li>The stack and dump registers of the NXP SECD Machine would usually be empty in the initial state.</li>
</ul>

<p>
Once the NXP SECD Machine stops (hitting the <code>STOP</code> control), the stack will show the values of the suggested hypotheses at start, and the environment will be updated with all the evaluations of hypotheses, rules, conditions and variables processed during the interactive session.
</p>

<p>
This design feature also folds both the <i>production memory</i>, containing rules, and the <i>working memory</i>, containing data, values and conclusions, into the same implementation structure, the environment. It conflates short-term and long-term memory into the same register of the SECD Machine. The <i>agenda</i>, which is the high-level control structure of the NXP Architecture, is then mapped to the control list, the <code>c</code> register of the NXP SECD Machine.
</p>

<p>
Another consequence is that events in the environment now need to be monitored by the NXP Executive, outside of the SECD Machine itself. The NXP Executive needs notification of the changes of value in the environment, i.e. on delayed evaluations being forced, to trigger the appropriate side-effects. The implementation of the environment in the basic <code>funx</code> SECD Machine requires additional instrumentation in the <code>funxp</code> SECD variant. This is the core of the NXP Executive addition to the <code>funxp</code> SECD Machine.
</p>

<p>
The second design choice is to simplify the mapping of the agenda to the <code>c</code> register by lifting the control list to first-class citizenship in the SECD automaton transitions and introducing several new controls that alter the <code>c</code> register in-place. These new controls borrow heavily from the <i>continuation-passing style</i> (CPS) in functional programming languages studies, <sup><a id="fnr.30" class="footref" href="#fn.30">30</a></sup>
</p>

<pre class="example">
+--------------------++-----------------+        
|                    ||                 |        
| FUNXP SECD MACHINE ||  NXP EXECUTIVE  |        
|                    ||                 |    USER
|------------+       ||  E register API |        
| FUNX SECD  |       ||  C register API |        
|  MACHINE   |       ||                 |        
+--------------------++-----------------+        
</pre>

<p>
Using these new controls, the focus of attention of the problem-solving process is explicitly controlled in the NXP Executive. The new controls are used for implementing backward-chaining, where they act on the top of the control list as on a stack, as well as for forward-chaining and evocation where they act on the end of the control list. 
</p>

<p>
Finally the I/O with the user is managed by a new control which pauses the NXP SECD Machine when asking the user for a value. The NXP Executive implements the input of the user&rsquo;s answer, usually through a client user-interface (text-based in Emacs).
</p>
</div>
</div>

<div id="outline-container-orgd58d4ed" class="outline-3">
<h3 id="orgd58d4ed"><span class="section-number-3">5.2</span> I/O extensions</h3>
<div class="outline-text-3" id="text-5-2">
<p>
In order to handle the basic interaction of asking the user for the value of a variable, we introduce a new control <code>ASK v</code>, where <code>v</code> is a variable which may appear in a condition or an action sexp.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">s</th>
<th scope="col" class="org-left">e</th>
<th scope="col" class="org-left">c</th>
<th scope="col" class="org-left">d</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">s</td>
<td class="org-left">e</td>
<td class="org-left">(ASK v . c)</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">(v . s)</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">and stop</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
The transition of the <code>ASK</code> control pushes the variable on the stack and stops the execution process.
</p>

<p>
Execution of the SECD Machine is resumed by issuing the command <i>answer</i> with the optional argument set to <code>t</code>.
</p>

<p>
-- Function <b>secd-answer</b> state val [resume]
</p>
<div class="defun">
<p>
Assigns the value <i>val</i> to the variable on top of the stack in <i>state</i>, optionally resuming execution of the SECD Machine according to the value of <i>resume</i>.
</p>

</div>

<p>
With this minimal infrastructure in place, a variable mention in a rule, when not itself an hypothesis in another rule, is compiled to the promise:
</p>

<p>
<code>(pressure_out_P3 PROMISE ASK pressure_out_P3 UPD)</code>
</p>

<p>
for instance, here the variable is <code>pressure_out_P3</code> and the associated control list in the promise (ready to be pushed as a closure on the stack with the environment when needed, <code>LDP</code> control) simply asks the question and stops, waiting for an <i>answer</i> command to resume. 
</p>

<p>
This is the default output of the knowledge base compiler for variables in the current implementation. Should other data sources come into play, this implementation would require customization.
</p>
</div>
</div>

<div id="outline-container-org313ffd8" class="outline-3">
<h3 id="org313ffd8"><span class="section-number-3">5.3</span> Backward Chaining</h3>
<div class="outline-text-3" id="text-5-3">
<p>
In order to implement backward chaining we introduce NXP-specific controls which alter in-place the control list. These CPS operators represent the higher level agenda operations that drive the focus of attention in the NXP Architecture. These are <code>ALL n</code>, <code>ANY n</code> which work together with the <code>CPS</code> control, where <code>n</code> is a positive integer (the number of rules or the number of conditions in a LHS).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">s</th>
<th scope="col" class="org-left">e</th>
<th scope="col" class="org-left">c</th>
<th scope="col" class="org-left">d</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(p1 &#x2026; pn s)</td>
<td class="org-left">e</td>
<td class="org-left">(ALL n . c)</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">(<b>F</b> s)</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">if one of <i>pi</i> is <b>F</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(p1 &#x2026; pn s)</td>
<td class="org-left">e</td>
<td class="org-left">(AP0 CPS . c)</td>
<td class="org-left">((ALL n) d)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">if not</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(p1 &#x2026; pn s)</td>
<td class="org-left">e</td>
<td class="org-left">(ANY n . c)</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">(<b>T</b> s)</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">if one of <i>pi</i> is <b>T</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(p1 &#x2026; pn s)</td>
<td class="org-left">e</td>
<td class="org-left">(AP0 CPS . c)</td>
<td class="org-left">((ANY n) d)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">if not</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(p1 &#x2026; pn s)</td>
<td class="org-left">e</td>
<td class="org-left">(CPS . c)</td>
<td class="org-left">(([ALL, ANY, SEQ] d)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">;; Case: ALL</td>
</tr>

<tr>
<td class="org-left">(<b>F</b> s)</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">if <i>p1</i> is <b>F</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(p2 &#x2026; pn s)</td>
<td class="org-left">e</td>
<td class="org-left">(AP0 CPS . c)</td>
<td class="org-left">((ALL n-1) d)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">if <i>p1</i> is <b>T</b>, and n&gt;0</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(<b>T</b> s)</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">if all <i>pi</i> are <b>T</b></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">;; Case: ANY</td>
</tr>

<tr>
<td class="org-left">(<b>T</b> s)</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">if <i>p1</i> is <b>T</b></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(p2 &#x2026; pn s)</td>
<td class="org-left">e</td>
<td class="org-left">(AP0 CPS . c)</td>
<td class="org-left">((ANY n-1) d)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">if <i>p1</i> is <b>F</b>, and n&gt;0</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(<b>F</b> s)</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">if all <i>pi</i> are <b>F</b></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">;; Case:</td>
</tr>

<tr>
<td class="org-left">(p2 &#x2026; pn s)</td>
<td class="org-left">e</td>
<td class="org-left">(AP0 CPS . c)</td>
<td class="org-left">((SEQ n-1) d)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">if n&gt;0</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">s</td>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">if n = 0</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
The bulk of the evaluation work is done in the <code>CPS</code> transition. <code>ALL</code>, <code>ANY</code> and <code>SEQ</code> used for RHS actions (and forward chaining) all open the immediate evaluation of <code>n</code> promises loaded on the stack. So that the knowledge base compiler produces the following promises:
</p>

<dl class="org-dl">
<dt>Compiled hypothesis</dt><dd><code>(H PROMISE LDP rN ... LDP r1 ANY N UPD)</code>, where the <code>rI</code> are unique ids for the rules with given hypothesis.</dd>
<dt>Compiled LHS</dt><dd><code>(LDP cN ... LDP c1 ALL N)</code>, where the <code>cI</code> are unique ids for the conditions in the LHS of the rule.</dd>
<dt>Compiled RHS</dt><dd><code>(LDP aN ... LDP a1 SEQ N)</code>, where the <code>aI</code> are unique ids for the RHS actions</dd>
<dt>Compiled rule</dt><dd><code>(rule PROMISE LDP cN ... LDP c1 ALL N SEL (LDP aM ... LDP a1 SEQ M LDC *T* JOIN) (LDC *F* JOIN) UPD)</code> when there are <code>N</code> conditions and <code>M</code> actions.</dd>
</dl>

<p>
The knowledge base compiler produces an if-LHS-then-RHS construct for each rule, and a control list that performs a logical <code>OR</code> on these constructs in order to evaluate their hypotheses. The implementation of the <code>ANY</code>, <code>ALL</code>, and <code>SEQ</code> operators executes 2 steps: 
</p>
<ul class="org-ul">
<li>(i) a pre-execution scan is performed (except for <code>SEQ</code>) looking for promises already forced to <code>*T*</code> or <code>*F*</code> according to the logical operator (<code>OR</code>, <code>AND</code>) involved in the evaluation. When found, this value is directly propagated upwards to the rule, or to the hypothesis without further computation.</li>
<li>(ii) if none is found in the scan, the <code>ANY~/~CPS</code>, <code>ALL~/~CPS</code>, and <code>SEQ~/~CPS</code> implement a loop through the <code>N</code> promises on the stack, evaluating each of them in sequence until resulting in <code>*T*</code> or <code>*F*</code> according to the logical operator (<code>OR</code>, <code>AND</code>) involved in the evaluation; and all of them unconditionally  for <code>SEQ</code>.</li>
</ul>

<p>
This evaluation is performed by altering in-place the top level control list. The <code>AP0 CPS</code> sequence is repeatedly pushed on the head of the control list, as if on a stack, to switch the focus of attention immediately to the condition or action to be evaluated next.
</p>
</div>
</div>

<div id="outline-container-orge852ddd" class="outline-3">
<h3 id="orge852ddd"><span class="section-number-3">5.4</span> Forward Chaining</h3>
<div class="outline-text-3" id="text-5-4">
<p>
In forward chaining, a known data triggers evaluation of the conditions where it is mentioned. Should all the conditions in a LHS so triggered end up true, the rule is then deemed true (or false, respectively, if one of the said conditions is found false). Then again an evaluated rule triggers evaluation of its hypothesis, according to the heuristics option <code>secd--kb-option-forward-chaining-gate</code>.
</p>

<p>
In line with the original design choice of mapping the knowledge base to the environment register of the SECD Machine, the starting event is the assignment of a value to a variable, a condition, or a rule in the environment. We implement forward chaining as a callback to the NXP Executive from the SECD Machine on an update event of the <code>e</code> register. In the current implementation, the callback mechanism relies on Emacs-Lisp <i>hooks</i>, 
</p>

<p>
The environment register of the <code>funxp</code> machine supports two hooks:
</p>

<p>
-- Variable <b>secd-env-update-hook</b>
</p>
<div class="defvar">
<p>
Default is <code>nil</code>. The NXP Executive provides a forward chaining callback, the function <code>secd-comp--kb-forward-hook</code> which needs to be installed before running an interactive session if forward chaining is required. This is done:
</p>

<p>
<code>(add-hook 'secd-env-update-hook 'secd-comp--kb-forward-hook)</code>
</p>

<p>
by default when calling <code>secd-comp--kb-knowcess</code>, <a href="#org91edd7e">5</a>.
</p>

<p>
Each hook in the list is passed three arguments: 
</p>
<dl class="org-dl">
<dt>promise</dt><dd>the variable name (each entity in the knowledge base is represented as a promise in the environment register)</dd>
<dt>val</dt><dd>the value assigned to that promise by the evaluation process</dd>
<dt>state</dt><dd>the current state of the SECD Machine <code>(s e c d)</code></dd>
</dl>

</div>

<p>
-- Variable <b>secd-env-locate-hook</b>
</p>
<div class="defvar">
<p>
Default is <code>nil</code>. This hook lists functions to be called on a query to environment for the value of a <code>funxp</code> variable. It calls each hook function,
stopping if one of them succeeds by returning a non-‘nil’ value.
</p>

<p>
Each hook function is passed the arguments:
</p>
<dl class="org-dl">
<dt>promise</dt><dd>the variable name (each entity in the knowledge base is represented as a promise in the environment register)</dd>
<dt>state</dt><dd>the current state of the SECD Machine <code>(s e c d)</code></dd>
</dl>

<p>
If this function stops because one of the hook functions returns a
non-‘nil’ value, it returns that value; otherwise it returns the default value found in the environment register.
</p>

</div>

<p>
The latter hook can be used to implement external data sources for instance, or to notify an external program, such as a client user interface, that the variable evaluation is needed in the problem-solving process.
</p>

<p>
The default forward chaining hook operates by altering in-place the top level control list. In contrast to backward chaining though, it adds to the <i>tail</i> of the control list, just before the terminating <code>STOP</code> control, posting conditions, rules or hypotheses to be evaluated once the current focus of attention is completed. Should this alternation of backward and forward chaining require additional customization or a change of priority, this hook should be removed from the environment hook list and simply replaced by an appropriate one. This extra flexibility encourages experimenting with different agenda control structures to capture problem-specific heuristics.
</p>
</div>
</div>

<div id="outline-container-orgd1384c2" class="outline-3">
<h3 id="orgd1384c2"><span class="section-number-3">5.5</span> Evocation</h3>
<div class="outline-text-3" id="text-5-5">
<p>
The evocation also makes use of the <code>secd-env-update-hook</code>. The NXP Executive installs a second default hook for evocation according to the value of the heuristics option: <code>secd--kb-option-context</code>, <a href="#org9cd7a5e">4.2.4</a>.
</p>

<p>
-- Function <b>secd-comp--kb-context-hook</b> var val state
</p>
<div class="defun">
<p>
Traverse context links from hypothesis (transitive closure), post evaluation. Note that since it is triggered post evaluation the hook is modulated by the heuristics option controlling forward chaining of rules, the gating <code>secd--kb-option-forward-chaining-gate</code>.
</p>

</div>

<p>
The default hook implements evocation by posting hypotheses, found by traversing context links, at the tail of the top level control list, just before the <code>STOP</code> control. They compete therefore with forward chaining hypotheses postings, priority-wise. The hook mechanism allows for easy customization should the default switch of the focus of attention be adapted to the task domain.
</p>
</div>
</div>

<div id="outline-container-org86dbdf2" class="outline-3">
<h3 id="org86dbdf2"><span class="section-number-3">5.6</span> Compiling it all together</h3>
<div class="outline-text-3" id="text-5-6">
<p>
Bringing it all together, the knowledge base compiler produces an environment for the <code>funxp</code> SECD Machine from the well-formed sexp representing the list of rules. The environment serves as the initial content of the <code>e</code> register of the machine. It contains uniquely identified promises for each variable, condition, action, rule, and hypothesis in the knowledge base.
</p>

<p>
This information is insufficient as is, however. The NXP Executive, and particularly the default hooks it installs for forward chaining and context associations, require additional information.
</p>

<p>
The last major design choice in this implementation is to represent this meta-information on the structure of the knowledge base as simple association lists and store them also in the environment <code>e</code> register. (The dump <code>d</code> register is an alternative that could also be considered, if we would rather dedicate the <code>e</code> register to the knowledge based computation; any database external to the SECD Machine would also be satisfactory.)
</p>

<p>
Hence the knowledge compiler adds several passes to the generation of the promises, adding new meta-information as association lists to the environment. We call each of these alist, a <i>decoration</i> and it is associated to a <i>decorator</i> in the environment:
</p>

<dl class="org-dl">
<dt><code>*FWRD-SIGNS*</code></dt><dd>Keeps track for each variable of all the conditions and rules in which it is mentioned. Used by the forward chaining hook.</dd>
</dl>
<dl class="org-dl">
<dt><code>*FWRD-RULES*</code></dt><dd>Keeps track of each rule-hypothesis association. Used by the forward chaining hook.</dd>
</dl>
<dl class="org-dl">
<dt><code>*BWRD-SIGNS*</code></dt><dd>Keeps track of which rules&rsquo; RHS may set a variable&rsquo;s value. Used in backward chaining when the heuristics option. <code>secd--kb-option-backward-chaining-rhs</code> is <code>t</code>.</dd>
</dl>
<dl class="org-dl">
<dt><code>*SECD-TOPLEVEL-CLIST*</code></dt><dd>The head of the top level control list. Used by all CPS operators, also in both forward chaining and context default hooks.</dd>
</dl>
<dl class="org-dl">
<dt><code>*KB-PROMPTS*</code></dt><dd>Keeps track for each variable of the possible values found in LHS and RHS of rules. Used in answering a question to present a few expected values.</dd>
</dl>
<dl class="org-dl">
<dt><code>*CONTEXT-SIGNS*</code></dt><dd>Keeps track of all context symbols (or sexps) attached to each hypothesis.</dd>
</dl>
<dl class="org-dl">
<dt><code>*CONTEXT-HYPOS*</code></dt><dd>Keeps track, for each hypothesis, of all hypotheses that can be reached by traversing the context links (transitive closure).</dd>
</dl>
<dl class="org-dl">
<dt><code>*COND-SOURCE*</code></dt><dd>Keeps a copy of the well-formed <code>funxp</code> LISP variant sexp for each condition. Used in the what-if mechanism to <i>un-force</i> a promise back to its delayed evaluation status.</dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-org3c2e12c" class="outline-2">
<h2 id="org3c2e12c"><span class="section-number-2">6</span> An Emacs-based client</h2>
<div class="outline-text-2" id="text-6">
<p>
This last section describes a minimal text-based user interface to the <code>funxp</code> NXP Architecture implementation describes above. The choice of Emacs-Lisp as the implementation language for the NXP SECD Abstract Machine naturally leads to an Emacs text-based client, also written in Emacs-Lisp.
</p>

<p>
Even without porting the SECD Machine to a different language and environment it is possible to use this Emacs-Lisp implementation as a server to client GUIs developed for a different execution environment. (Or from Emacs issue commands to an ad hoc GUI server, for example using Python + GTK).
</p>

<p>
In this section we focus on the discussion of the <i>Encyclopedia</i>, a basic client interface for interactive sessions in Emacs.
</p>
</div>

<div id="outline-container-orge50aee3" class="outline-3">
<h3 id="orge50aee3"><span class="section-number-3">6.1</span> Session. Interactivity. Trace and protocol.</h3>
<div class="outline-text-3" id="text-6-1">
<p>
A client user interface introduces the notion of interactive session. The session keeps track of all information required for interacting with the user of the <code>funxp</code> system before, during and after a problem-solving performance in the chosen task domain.
</p>

<p>
The session acts as a global variable acted upon by the following commands:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Status of session</th>
<th scope="col" class="org-left">Type of commands</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">INITIALIZED</td>
<td class="org-left">Load knowledge bases</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Suggest hypothesis</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Volunteer value</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Explore rules, data</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">RUNNING</td>
<td class="org-left">Answer question</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Suggest hypothesis</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Volunteer value</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Explore rules, data</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Visualize focus of attention</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">CLOSED</td>
<td class="org-left">What-if queries</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Explore rules, data</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Visualize conclusions, values</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Reset</td>
</tr>
</tbody>
</table>

<p>
Other client applications would rather use a programmatic API to issue commands and queries to the SECD Machine in its different states.
</p>

<p>
The Encyclopedia is a special buffer in Emacs to visualize and interact with the variables and hypotheses in a knowledge base. It is setup by the function that initialize a new session on a given knowledge base.
</p>

<p>
-- Function <b>nxp_session</b> kb
</p>
<div class="defun">
<p>
The function initializes a new session by compiling the knowledge base argument <i>kb</i>. It opens a new Encyclopedia buffer, <code>*NXP-ENCY*</code> and returns a session (global) variable, called <i>session</i>.
</p>

<p>
In addition it opens a few tracing buffers:
</p>
<dl class="org-dl">
<dt><b>SECD-COMP</b></dt><dd>Traces the compilation of the knowledge base and report errors.</dd>
<dt><b>SECD-PROTOCOL</b></dt><dd>Step by step trace of the SECD Machine execution of the top level control list/</dd>
<dt><b>NXP-SESSION</b></dt><dd>A buffer keeping track of the high-level interactions of Q&amp;A while the session runs.</dd>
</dl>

</div>
</div>
</div>

<div id="outline-container-org5df8cdf" class="outline-3">
<h3 id="org5df8cdf"><span class="section-number-3">6.2</span> Encyclopedia and tree representation. Commands.</h3>
<div class="outline-text-3" id="text-6-2">
<p>
The Encyclopedia buffer, <code>*NXP-ENCY*</code>, acts as the main control dashboard of the <code>funxp</code> interactive session. It is initialized with a global Emacs-Lisp variable, <i>session</i>.
</p>

<p>
It displays two tables, one for hypotheses, the other for variables in the knowledge base, with names and values at any given time in the interactive session. It is implemented with the so-called <i>Ewoc</i> library, meaning “Emacs’s Widget for Object Collections”, 
</p>

<p>
The Encyclopedia supports a very limited set of commands:
</p>
<blockquote>
<dl class="org-dl">
<dt>`q&rsquo;</dt><dd>Kill Encyclopedia buffer.</dd>
<dt>`k&rsquo;</dt><dd>Suggest hypo at point and knowcess immediately.</dd>
<dt>`w&rsquo;</dt><dd>Volunteer, or What-if, data at point and knowcess immediately.</dd>
<dt>`a&rsquo;</dt><dd>Answer pending question and resume session.</dd>
<dt>`r&rsquo;</dt><dd>Restart session.</dd>
<dt>`t&rsquo;</dt><dd>Open backward-chaining tree visualization of hypo at point.</dd>
</dl>
</blockquote>

<p>
At any point during a session, pressing <code>t</code> when the cursor is over an hypothesis opens up a simple data visualization of the or-and tree of rules and conditions (recursively) attached to the selected hypothesis. The tree visualization is in its own separate buffer, <code>*NXP-TREE*</code>. Its implementation uses the <code>tree-widget</code> Emacs-Lisp library.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf18ee68" class="outline-2">
<h2 id="orgf18ee68"><span class="section-number-2">7</span> Bibliography</h2>
<div class="outline-text-2" id="text-7">
<p>
Source: <code>funx.bib</code>.
</p>

<p>
1. Jean-Marie Chauvet. <i>The 30-Year Cycle In The AI Debate</i>. CoRR, 2018.
</p>

<p>
2. Rougier, Nicolas P. and Noelle, David C. and Braver, Todd S. and Cohen, Jonathan D. and O Reilly, Randall C.. <i>Prefrontal cortex and flexible cognitive control: Rules without symbols</i>. National Academy of Sciences, 2005.
</p>

<p>
3. Newell, Allen and Simon, H. A.. <i>Human Problem Solving</i>. Prentice-Hall, Inc., 1972.
</p>

<p>
4. Waterman, D. A. and Hayes-Roth, Frederick. <i>Pattern-Directed Inference Systems</i>. Academic Press, Inc., 1978.
</p>

<p>
5. Feigenbaum, Edward A. and Feldman, Julian. <i>Computers &amp; Thought</i>. McGraw-Hill, 1963.
</p>

<p>
6. Chuck Rieger. <i>Spontaneous computation in cognitive models</i>. SIGART Newsl., 1977.
</p>

<p>
7. Emil L. Post. <i>Formal Reductions of the General Combinatorial Decision Problem</i>. Association for Symbolic Logic, 1943.
</p>

<p>
8. A. A. Markov. <i>Theory of Algorithms</i>. Association for Symbolic Logic, 1957.
</p>

<p>
9. Floyd, Robert W.. <i>An Algorithm for Coding Efficient Arithmetic Operations</i>. Association for Computing Machinery, 1961.
</p>

<p>
10. Chomsky, Noam. <i>Syntactic Structures</i>. Mouton and Co., 1957.
</p>

<p>
11. Paycha, F.. <i>Cybern{\&rsquo;e}tique de la consultation: logique et morale de la m{\&rsquo;e}decine</i>. Gauthier-Villars, 1963.
</p>

<p>
12. Alain Rappaport and Jean-Marie C. Chauvet. <i>Symbolic Knowledge Processing for he Acquisition of Expert Behavior: A Study in Medicine</i>. Carnegie Mellon University, 1984.
</p>

<p>
13. Clancey, William J. and Shortliffe, Edward H.. <i>Readings in Medical Artificial Intelligence: The First Decade</i>. Addison-Wesley Longman Publishing Co., Inc., 1984.
</p>

<p>
14. Buchanan, Bruce G. and Shortliffe, Edward H.. <i>Rule Based Expert Systems: The Mycin Experiments of the Stanford Heuristic Programming Project (The Addison-Wesley Series in Artificial Intelligence)</i>. Addison-Wesley Longman Publishing Co., Inc., 1984.
</p>

<p>
15. Guy L. Steele Jr.. <i>Debunking the &ldquo;expensive procedure call&rdquo; myth or, procedure call implementations considered harmful or, LAMBDA: The Ultimate GOTO</i>. ACM, 1977.
</p>

<p>
16. Steele Jr., Guy Lewis and Sussman, Gerald Jay. <i>LAMBDA: the ultimate imperative</i>. , 1976.
</p>

<p>
17. Moses, Joel. <i>The Function of FUNCTION in LISP or Why the FUNARG Problem Should Be Called the Environment Problem</i>. Association for Computing Machinery, 1970.
</p>

<p>
18. Barstow, David R. and Shrobe, Howard E. and Sandewall, Erik.. <i>Interactive programming environments / editors, David R. Barstow, Howard E. Shrobe, Erik Sandewall</i>. McGraw-Hill New York, 1984.
</p>

<p>
19. Appel, Andrew W.. <i>Compiling with Continuations</i>. Cambridge University Press, 1991.
</p>

<p>
20. Bundy, Alan and Wallen, Lincoln. <i>Lispkit</i>. Springer Berlin Heidelberg, 1984.
</p>

<p>
21. Henderson, Peter and Morris, James H.. <i>A Lazy Evaluator</i>. Association for Computing Machinery, 1976.
</p>

<p>
22. P. Henderson. <i>Functional Programming - Application and Implementation</i>. Prentice-Hall Int. Series in Computer Science, 1980.
</p>

<p>
23. Peter Henderson. <i>Functional programming - application and implementation</i>. Prentice Hall, 1980.
</p>

<p>
24. Kenneth R. Traub. <i>Implementation of non-strict functional programming languages</i>. Pitman, 1991.
</p>

<p>
25. Daniel P. Friedman and David S. Wise. <i>CONS Should Not Evaluate its Arguments</i>. Edinburgh University Press, 1976.
</p>

<p>
26. R. M. KELLER and G. LINDSTROM and S. PATIL. <i>A loosely-coupled applicative multi-processing system*</i>. , 1979.
</p>

<p>
27. D. Turner. <i>A new implementation technique for applicative languages</i>. Software: Practice and Experience, 1979.
</p>

<p>
28. Landin, P. J.. <i>The Mechanical Evaluation of Expressions</i>. The Computer Journal, 1964.
</p>

<p>
29. Michalski, S Ryszard and Carbonell, G Jaime and Mitchell, M Tom. <i>Machine Learning an Artificial Intelligence Approach Volume I</i>. Tioga, 1984.
</p>

<p>
30. Michalski, S Ryszard and Carbonell, G Jaime and Mitchell, M Tom. <i>Machine Learning an Artificial Intelligence Approach Volume II</i>. Morgan Kaufmann Publishers Inc., 1986.
</p>

<p>
31. Newell, Allen. <i>Unified Theories of Cognition</i>. Harvard University Press, 1990.
</p>

<p>
32. Smolensky, Paul. <i>On the proper treatment of connectionism</i>. Cambridge University Press, 1988.
</p>

<p>
33. Szolovits, P. and American Association for the Advancement of Science and American Association for the Advancement of Science. Section on Medical Sciences and American Association for the Advancement of Science. National Meeting. <i>Artificial Intelligence In Medicine</i>. Westview Press, 1982.
</p>
</div>
</div>


<div id="outline-container-org865591a" class="outline-2">
<h2 id="org865591a"><span class="section-number-2">8</span> Index</h2>
<div class="outline-text-2" id="text-8">
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Development of an expert system, <i>Daniel Sagalowicz</i>, Expert System, Vol. 1, Issue 2, Oct. 1984. 
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
The philosophical perspective so stated does not focus on <i>how</i> the physical symbol system itself is actually realized. It obviously suggests that the human mind is such as system but also that, implicitly, physical symbol systems may be realised in Turing/Von Neumann computer architectures, and computer programs more specifically. And thus in the 1960s and 1970s it became an established practice to research theories about memory, reasoning or beliefs on computer programs as an experimental substrate, drawing conclusions deemed legitimate for cognition in the human mind. Contrast this to current Computational Neurosciences and to Connectionism&rsquo;s neural networks architectures, old and new.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
In this context, progress in AI research was exemplified by  comprehensive descriptions of computer programs as landmark systems.  for such descriptions of the 1960s and 1950s systems. The import of the analogy between cognitive processes, in the human mind, and the workings of a computer program, was also felt in philosophy with the dramatic revival in the 1970s of <i>The Language of Thought</i> hypothesis. The watershed was publication of Jerry Fodor&rsquo;s The Language of Thought (1975), triggering discussions and debates which continue to figure prominently within philosophy and cognitive science today. From a philosophical perspective, research programs such as &ldquo;naturalizing intentionality&rdquo; and &ldquo;naturalizing consciousness&rdquo; are still active although under a variety of cognitive assumptions, mirrorring the outpouring of results in neurosciences and computer science in the last decades.
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
Designing a Rule System That Searches for Scientific Discoveries, <i>Douglas B. Lenat</i> and <i>Gregory Harris</i>, CMU CS, Apr. 1977.
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">
Thinking May Be More Than Computing, <i>Peter Kugel</i>, Cognition, 22 (1986) pp. 137-198. 
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6">6</a></sup> <div class="footpara"><p class="footpara">
R1: An Expert in the Computer Systems Domain, <i>John McDermott</i>, Proceedings of the First AAAI Conference on Artificial Intelligence. AAAI&rsquo;80. Stanford, California: AAAI Press: 269–271, 1980. (The paper won the AAAI Classic Paper Award in 1999.)
</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7">7</a></sup> <div class="footpara"><p class="footpara">
Rete: A Fast Algorithm for the Many Pattern/Many Object Pattern
Match Problem, <i>Charles L. Forgy</i>, Artificial Intelligence 19, pp. 17-37, 1982.
</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8">8</a></sup> <div class="footpara"><p class="footpara">
EMYCIN : A Knowledge Engineer ’ s Tool for Constructing
Rule-Based Expert Systems, <i>William, Van Melle, E. Shortliffe,
Bruce. and G. Buchanan</i>, Pergamon-lnfotech state of the art report on
machine intelligence, pp. 249-263. Maidenhead, Berkshire, U.K.:
Infotech Ltd., 1981.
</p></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9">9</a></sup> <div class="footpara"><p class="footpara">
ONCOCIN: an expert system for oncology protocol management, <i>Edward H. Shortliffe, A. Carlisle Scott, Miriam B. Bischoff, A. Bruce Campbell, William Van Melle, and Charlotte D. Jacobs.</i> In Proceedings of the 7th international joint conference on Artificial intelligence - Volume 2 (IJCAI&rsquo;81). Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 876–881, 1981
</p></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10">10</a></sup> <div class="footpara"><p class="footpara">
The order of the rules in the list attached to a goal is assumed to be
arbitrary, and all the rules are applied unless one of them succeeds and
concludes the value of the parameter with certainty (in which case the
remaining rules are superfluous).
</p></div></div>

<div class="footdef"><sup><a id="fn.11" class="footnum" href="#fnr.11">11</a></sup> <div class="footpara"><p class="footpara">
Internist-I, an Experimental Computer-Based Diagnostic Consultant for General Internal Medicine, <i>Miller, Randolph A., Harry E. Pople Jr, and Jack D. Myers.</i> New England Journal of Medicine 307.8 (1982): 468-476. 
</p></div></div>

<div class="footdef"><sup><a id="fn.12" class="footnum" href="#fnr.12">12</a></sup> <div class="footpara"><p class="footpara">
During the summer 1983, the authors visited Dr Peter Szolovits group at MIT and also met there with Dr. Ramesh Patil. 
</p></div></div>

<div class="footdef"><sup><a id="fn.13" class="footnum" href="#fnr.13">13</a></sup> <div class="footpara"><p class="footpara">
Solutions to the mind/body problem usually try to answer questions such as: What is the ultimate nature of the mental? At the most general level, what makes a mental state mental? Or more specifically, What do thoughts have in common in virtue of which they are thoughts? That is, what makes a thought a thought? What makes a pain a pain? <i>Cartesian Dualism</i> said the ultimate nature of the mental was to be found in a special mental substance. <i>Behaviorism</i> identified mental states with behavioral dispositions; <i>physicalism</i> in its most influential version identifies mental states with brain states. <i>Block, Ned</i>, What is Functionalism? The Encyclopedia of Philosophy Supplement, (1996).
</p></div></div>

<div class="footdef"><sup><a id="fn.14" class="footnum" href="#fnr.14">14</a></sup> <div class="footpara"><p class="footpara">
The causal approach was also characteristic of D.M. Armstrong&rsquo;s careful conceptual analysis of mental states and processes, such as perception and the secondary qualities, sensation, consciousness, belief, desire, emotion, voluntary action, in his A Materialist Theory of the Mind (1968).
</p></div></div>

<div class="footdef"><sup><a id="fn.15" class="footnum" href="#fnr.15">15</a></sup> <div class="footpara"><p class="footpara">
Not to mention neurosciences. See e.g. Toward discovery science of human brain function, <i>Bharat B. Biswal, et al.</i>, Proceedings of the National Academy of Sciences Mar 2010, 107 (10) 4734-4739; (DOI: 10.1073/pnas.0911855107).
</p></div></div>

<div class="footdef"><sup><a id="fn.16" class="footnum" href="#fnr.16">16</a></sup> <div class="footpara"><p class="footpara">
Troubles with functionalism. <i>Ned Block</i>, Minnesota Studies in the Philosophy of Science, 9:261-325, (1978).
</p></div></div>

<div class="footdef"><sup><a id="fn.17" class="footnum" href="#fnr.17">17</a></sup> <div class="footpara"><p class="footpara">
From Operational Semantics to Abstract Machines, <i>John Hannan, Dale Miller</i>, (1992). 
</p></div></div>

<div class="footdef"><sup><a id="fn.18" class="footnum" href="#fnr.18">18</a></sup> <div class="footpara"><p class="footpara">
Abstract machines for programming language implementation, <i>Stephan Diehl, Pieter Hartel, Peter Sestoft</i>, Future Generation Computer Systems 16 739–751, (2000).
</p></div></div>

<div class="footdef"><sup><a id="fn.19" class="footnum" href="#fnr.19">19</a></sup> <div class="footpara"><p class="footpara">
A string processing language is a programming language that
focuses on string processing rather than processing numeric
data. String processing languages have been around for decades in the
form of command shells, programming tools, macro processors, and
scripting languages. This latter category has become prominent as
scripting language are used to ‘glue’ components together. There are 
myriads of scripting languages today.
</p></div></div>

<div class="footdef"><sup><a id="fn.20" class="footnum" href="#fnr.20">20</a></sup> <div class="footpara"><p class="footpara">
The history of abstract machines for functional programming
languages is a fascinating subject of research. Cardelli’s Functional
Abstract Machine (1983) is a much extended and optimized SECD machine
used in the first native-code implementation of ML. The Categorical
Abstract Machine (1985) was developed by Cousineau et al.: its
instructions correspond to the constructions of a Cartesian closed
category, identity, composition, abstraction, application, pairing,
and selection. It was the base for the CAML implementation of ML. The
Zinc Abstract Machine (1990) developed by Leroy permits more efficient
execution. It is an optimized, strict version of the Krivine
machine. This machine is the basis of the bytecode versions of Leroy’s
Caml Light and Objective Caml implementations, and is used also in
Moscow ML.
</p></div></div>

<div class="footdef"><sup><a id="fn.21" class="footnum" href="#fnr.21">21</a></sup> <div class="footpara"><p class="footpara">
TIM: A simple, lazy abstract machine to execute supercombinatorics. <i>Fairbairn, J. and S. Wray.</i>, FPCA (1987). 
</p></div></div>

<div class="footdef"><sup><a id="fn.22" class="footnum" href="#fnr.22">22</a></sup> <div class="footpara"><p class="footpara">
The abc-machine: A sequential stack-based abstract machine for graph rewriting, <i>Koopman, P. W. M., M. C. J. D. van Eekelen, E. G. J. M. H. Nocker, M. J. Plasmaijer and J. E. W. Smetsers</i>, Technical Report 90-22, Univ. Nijmegen, (1990).
</p></div></div>

<div class="footdef"><sup><a id="fn.23" class="footnum" href="#fnr.23">23</a></sup> <div class="footpara"><p class="footpara">
Parallel graph reduction with the (v , G)-machine. <i>Lennart Augustsson and Thomas Johnsson.</i> In Proceedings of the fourth international conference on Functional programming languages and computer architecture (FPCA 1989) <a href="https://doi.org/10.1145/99370.99386">https://doi.org/10.1145/99370.99386</a> 
</p></div></div>

<div class="footdef"><sup><a id="fn.24" class="footnum" href="#fnr.24">24</a></sup> <div class="footpara"><p class="footpara">
See also: A LispKit Lisp Programming Language, a Modified Denotational Semantics Approach. <i>Jerinic, Ljubomir.</i> (1993); An experiment in practical semantics, <i>Maurice Naftalin</i>, ESOP 1986: ESOP 86 pp 144-159 (1986); A Compiler For Lispkit Targetted At Henderson&rsquo;s SECD Machine, <i>Simpson, T.; Birtwistle, G.; Hermann, M.; Graham, B.</i>, Technical Report, University of Calgary (1989).
</p></div></div>

<div class="footdef"><sup><a id="fn.25" class="footnum" href="#fnr.25">25</a></sup> <div class="footpara"><p class="footpara">
For more formal elaborations of the SECD machine see: Call-by-Name, Call-by-Value and the Lambda Calculus, <i>Gordon Plotkin</i> (Theoretical Computer Science , Vol. 1, pp. 125-159, 1975); The Tail-Recursive SECD Machine, <i>John D. Ramsdell</i>, Journal of Automated Reasoning volume 23, p. 43–62 (1999); A Rational Deconstruction of Landin&rsquo;s SECD Machine, <i>Olivier Danvy</i>, In: Grelck C., Huch F., Michaelson G.J., Trinder P. (eds) Implementation and Application of Functional Languages. IFL 2004. Lecture Notes in Computer Science, vol 3474. Springer, Berlin, Heidelberg. <a href="https://doi.org/10.1007/11431664_4">https://doi.org/10.1007/11431664_4</a> (2005); The SECD Microprocessor: A Verification Case Study, <i>Brian T. Graham</i>, The Springer International Series in Engineering and Computer Science (1992).
</p></div></div>

<div class="footdef"><sup><a id="fn.26" class="footnum" href="#fnr.26">26</a></sup> <div class="footpara"><p class="footpara">
We refer to the following for multiprocessing aspects of implementation:   See also: QLISP: A Language For The Interactive Development Of Complex Systems, <i>E. Sacerdoti, R. Fikes, R. Reboh, D. Sagalowicz, R. J. Waldinger, B. M. Wilber</i>, Artificial Intelligence Center, SRI, Technical Note 120, March 1976.
</p></div></div>

<div class="footdef"><sup><a id="fn.27" class="footnum" href="#fnr.27">27</a></sup> <div class="footpara"><p class="footpara">
Merits of both interpretations are compared e.g. in The spineless tagless G-machine, <i>Simon L Peyton Jones, Jon Salkild</i>, Proceedings of the fourth international conference on Functional programming languages and computer architecture, pp. 184-201, (1989). 
</p></div></div>

<div class="footdef"><sup><a id="fn.28" class="footnum" href="#fnr.28">28</a></sup> <div class="footpara"><p class="footpara">
See e.g. A Comparative Study Of Control Strategies For Expert Systems:
AGE Implementation Of Three Variations Of PUFF, <i>Nelleke Aiello</i>,  AAAI-83 Proceedings, (1983). And  
</p></div></div>

<div class="footdef"><sup><a id="fn.29" class="footnum" href="#fnr.29">29</a></sup> <div class="footpara"><p class="footpara">
For illuminating discussions, see Heuristic Methods for Imposing Structure on Ill-Structured Problems: The Structuring of Medical Diagnostics, <i>Harry E. Pople, Jr.</i> in Artificial Intelligence in Medicine, <i>Edited by Peter Szolovits</i>, AAAS Selected Symposium 51, (1982); The Structure of Ill Structured Problems, <i>Herbert A. Simon</i>, Artificial Intelligence 4, p. 181-201, (1973); Clinical Problem Solving: A Behavioral Analysis, <i>J.P. Kassirer and G.A. Gorry</i>, Ann. Int. Med. 89, 245, (1978); Medical Problem Solving: An Analysis of Clinical Reasoning, <i>A.S. Elstein, L.A. Shulman, and S.A. Sprafka</i>, Harvard University Press, (1978).
</p></div></div>

<div class="footdef"><sup><a id="fn.30" class="footnum" href="#fnr.30">30</a></sup> <div class="footpara"><p class="footpara">
See also: Monadic Style Control Constructs for Inference Systems, <i>Jean-Marie Chauvet</i>, Computer Science, ArXiv, (2002). 
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="date">Date: 2021-01-11 lun. 00:00</p>
<p class="author">Author: jmc</p>
<p class="date">Created: 2021-02-13 sam. 20:12</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
