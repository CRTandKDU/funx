#+TITLE: README revisions file
#+SUBTITLE: NXP Runtime
#+AUTHOR: jmc

* DONE Factored out environment management. Forward infra.
The access and update environment functions are isolated in their own group, and hooks are installed for update events. Hook functions support the tentative signature ~(lambda (var-name value &optional state)~.

This is to be used in conjunction with additional kb-globals compiled to the environment by the kb-compiler:
#+BEGIN_SRC emacs-lisp
(defconst secd--kb-forward-chaining-signs  '*FWRD-SIGNS*)
(defconst secd--kb-forward-chaining-rules  '*FWRD-RULES*)
#+END_SRC

Both are alists from signs to list of rules, and from rules to hypos respectively. They represent forward-chaining links at runtime.

* DONE Knowledge base compiler <2020-12-12 sam.>
Fixed the strict compiler so that AP0/UPD allow promises to be fetched either from the environment with LDP or from the control list with LDE.

Initial knowledge base compiler, based on a lazy variant of the fixed strict compiler. The variant compiles all variables in conditions to promises LDP <var> AP0 rather than LD <var>. Note that the variant is strict: it evaluates the promise immediately.

Syntax for knowledge bases:

((rule <hypo> ((cond-sexp) ... (cond-sexp)))
 (rule <hypo> ((cond-sexp) ... (cond-sexp)))
 ...
 (rule <hypo> ((cond-sexp) ... (cond-sexp)))
)

* DONE Strict compiler <2020-12-05 sam.>
First implementation, following Henderson's book (p. 340), of a compiler for the simple variant of Lispkit, without the NXP extensions.

The variant has QUOTE, ATOM, CAR, CDR, CONS, EQ, LEQ, ADD/SUB/MUL/DIV/REM, IF, LAMBDA, LET and Application. Values are quoted, any other atom is a variable.

* DONE NXP Goal/Subgoal hierachy <2020-11-30 lun.>
Implemented the specific control used in NXP goal/subgoal hierachies
under specific mnemonics ANY, ALL which operates like sequences of
applications on boolean promises (see LDP/UPD LDE/UPD).

Continuation Passing Style is used for this implementation by
modifying the top of the control-list and the stack, according to the
NXP goal/subgoal specific handling (pre-fetching and OR/AND hierarchy).
  - CPS family (ANY, ALL, NOT, /CPS/)

The CPS implementation supersedes a restricted interpretation of ANY,
ALL operators to their prefetching phase (still available in the
LAZY family of operators).
  
* DONE Henderson's delay/force from Lispkit <2020-11-26 jeu.>
Implemented in ~secd-lazy-group.el~ which defines controls:
  - LDE Immediate load of a promise
  - LDP Loads a named promise from environment
  - AP0 Switch to execution of promise on stack
  - UPD Terminates promise and store value, if required

Implemented special "optimized" logical operators for NXP. They operate
on Boolean promises (returning ~*T*~ or ~*F*~).
  - ANY n Returns ~*T*~ if one of the n b-promises on stack executes to ~*T*~
  - ALL n Returns ~*T*~ if all of the n b-promises on stack executes to ~*T*~
  - NOT   Inverts the top of stack b-promise

ANY and ALL are first preprocessed, looking for already executed
b-promises with values ~*T*~ or ~*F*~ respectively to conclude early
without further evaluation. If this is not the case b-promises are
executed in stack order until the first that returns ~*T*~ or ~*F*~
respectively. When none meet the test, the negative result is
returned. This is a kind of lenient evaluation in the NXP context.

* DONE Core functional runtime <2020-11-11 mer.>
Implemented the core SECD machine from Henderson's book. Controls are
grouped into:
  - LD family (LDC, LD, LDF)
  - OPS family (CAR, CDR, ATOM, CONS, SEL/JOIN, EQ LEQ)
  - FUN family (AP/RTN, DUM/RAP)
  - Arithmetic family (ADD, SUB, MUL, DIV, REM)
  - I/O family (ASK)

The SECD machine (runtime) is in ~secd-exec.el~. Operates on
underlying emacs-lisp atoms but operations on integer-typed atoms only
are from the arithmetic group.

